--- a/drivers/mtd/chips/cfi_cmdset_0002.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/chips/cfi_cmdset_0002.c	2009-12-03 04:51:21.000000000 +0100
@@ -57,8 +57,6 @@
 static int cfi_amdstd_write_buffers(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
 static int cfi_amdstd_erase_chip(struct mtd_info *, struct erase_info *);
 static int cfi_amdstd_erase_varsize(struct mtd_info *, struct erase_info *);
-static int cfi_amdstd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
-static int cfi_amdstd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len);
 static void cfi_amdstd_sync (struct mtd_info *);
 static int cfi_amdstd_suspend (struct mtd_info *);
 static void cfi_amdstd_resume (struct mtd_info *);
@@ -284,12 +282,6 @@
 	}
 }
 
-static void fixup_s29glxxxp_lock(struct mtd_info *mtd, void *param)
-{
-	mtd->lock = cfi_amdstd_lock;
-	mtd->unlock = cfi_amdstd_unlock;
-}
-
 static struct cfi_fixup cfi_fixup_table[] = {
 	{ CFI_MFR_ATMEL, CFI_ID_ANY, fixup_convert_atmel_pri, NULL },
 #ifdef AMD_BOOTLOC_BUG
@@ -306,12 +298,6 @@
 	{ CFI_MFR_AMD, 0x1301, fixup_s29gl064n_sectors, NULL, },
 	{ CFI_MFR_AMD, 0x1a00, fixup_s29gl032n_sectors, NULL, },
 	{ CFI_MFR_AMD, 0x1a01, fixup_s29gl032n_sectors, NULL, },
-
-	/* Add block lock support for S29GL---P devices */
-	{ CFI_MFR_AMD, 0x2801, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2301, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2201, fixup_s29glxxxp_lock, NULL, },
-	{ CFI_MFR_AMD, 0x2101, fixup_s29glxxxp_lock, NULL, },
 #if !FORCE_WORD_WRITE
 	{ CFI_MFR_ANY, CFI_ID_ANY, fixup_use_write_buffers, NULL, },
 #endif
@@ -1734,77 +1720,6 @@
 	return 0;
 }
 
-/* #define DEBUG_AMDSTD_BLOCK_XXLOCK */
-#define AMDSTD_BLOCK_LOCK		((void *) 1)
-#define AMDSTD_BLOCK_UNLOCK		((void *) 2)
-static int do_amdstd_block_xxlock(struct map_info *map, struct flchip *chip,
-				  unsigned long adr, int len, void *thunk)
-{
-	struct cfi_private *cfi = map->fldrv_priv;
-	int ret;
-
-	DEBUG(MTD_DEBUG_LEVEL3, "MTD %s(): %sLOCK 0x%08lx len %d\n",
-	      __func__, (thunk == AMDSTD_BLOCK_LOCK) ? "" : "UN", adr, len);
-
-	spin_lock(chip->mutex);
-	ret = get_chip(map, chip, adr + chip->start, FL_LOCKING);
-	if (ret)
-		goto out_unlock;
-	chip->state = FL_LOCKING;
-
-	/* DYB Command Set Entry */
-	cfi_send_gen_cmd(0xAA, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x55, cfi->addr_unlock2, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0xE0, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-
-#ifdef DEBUG_AMDSTD_BLOCK_XXLOCK
-	printk(KERN_DEBUG "%s: block lock status @ 0x%08lx = 0x%02x [BEFORE]\n",
-	       __func__, adr, cfi_read_query(map, adr));
-#endif
-
-	/* DYB Set/Clear */
-	cfi_send_gen_cmd(0xA0, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	if (thunk == AMDSTD_BLOCK_LOCK)
-		map_write(map, CMD(0x00), chip->start + adr);
-	else
-		map_write(map, CMD(0x01), chip->start + adr);
-
-#ifdef DEBUG_AMDSTD_BLOCK_XXLOCK
-	printk(KERN_DEBUG "%s: block lock status @ 0x%08lx = 0x%02x [AFTER]\n",
-	       __func__, adr, cfi_read_query(map, adr));
-#endif
-
-	/* DYB Command Set Exit */
-	cfi_send_gen_cmd(0x90, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-	cfi_send_gen_cmd(0x00, cfi->addr_unlock1, chip->start, map, cfi,
-			 cfi->device_type, NULL);
-
-	chip->state = FL_READY;
-	put_chip(map, chip, adr + chip->start);
-	ret = 0;
-
-out_unlock:
-	spin_unlock(chip->mutex);
-	return ret;
-}
-
-static int cfi_amdstd_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	return cfi_varsize_frob(mtd, do_amdstd_block_xxlock, ofs, len,
-				AMDSTD_BLOCK_LOCK);
-}
-
-static int cfi_amdstd_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{
-	return cfi_varsize_frob(mtd, do_amdstd_block_xxlock, ofs, len,
-				AMDSTD_BLOCK_UNLOCK);
-}
-
 static int do_atmel_lock(struct map_info *map, struct flchip *chip,
 			 unsigned long adr, int len, void *thunk)
 {
--- a/drivers/mtd/devices/Kconfig	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/devices/Kconfig	2012-11-11 01:39:29.000000000 +0100
@@ -109,8 +109,7 @@
 	depends on (CPU_SUBTYPE_STX7105 || \
 		    CPU_SUBTYPE_STX5206 || \
 		    CPU_SUBTYPE_STX7108 || \
-		    CPU_SUBTYPE_FLI75XX || \
-		    CPU_SUBTYPE_STXH205)
+		    CPU_SUBTYPE_FLI7510)
 	help
 	  This provides a MTD device driver for the ST Microelectronics SPI
 	  FSM Serial Flash Controller, and connected Serial Flash device.
--- a/drivers/mtd/devices/stm_spi_fsm.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/devices/stm_spi_fsm.c	2012-11-11 01:39:29.000000000 +0100
@@ -31,16 +31,6 @@
 #define FLASH_PAGESIZE		256
 #define FLASH_MAX_BUSY_WAIT	(10 * HZ)	/* Maximum erase time */
 
-
-/*
- * Flags to tweak operation of default read/write/erase routines
- */
-#define CFG_READ_TOGGLE32BITADDR		0x00000001
-#define CFG_WRITE_TOGGLE32BITADDR		0x00000002
-#define CFG_WRITE_EX32BITADDR_DELAY		0x00000004
-#define CFG_ERASESEC_TOGGLE32BITADDR		0x00000008
-
-
 /*
  * SPI FSM Controller data
  */
@@ -48,10 +38,7 @@
 	struct mtd_info		mtd;
 	struct device		*dev;
 	struct resource		*region;
-	struct stm_pad_state	*pad_state;
 	struct stm_spifsm_caps	capabilities;
-	uint32_t		configuration;
-	uint32_t		fifo_dir_delay;
 
 	void __iomem		*base;
 	struct mutex		lock;
@@ -75,7 +62,6 @@
 #define FLASH_CMD_SE		0xd8
 #define FLASH_CMD_CHIPERASE	0xc7
 #define FLASH_CMD_WRVCR		0x81
-#define FLASH_CMD_RDVCR		0x85
 
 #define FLASH_CMD_READ		0x03	/* READ */
 #define FLASH_CMD_READ_FAST	0x0b	/* FAST READ */
@@ -90,26 +76,6 @@
 #define FLASH_CMD_WRITE_1_1_4	0x32	/* QUAD INPUT PROGRAM */
 #define FLASH_CMD_WRITE_1_4_4	0x12	/* QUAD INPUT EXT PROGRAM */
 
-#define FLASH_CMD_EN4B_ADDR	0xb7	/* Enter 4-byte address mode */
-#define FLASH_CMD_EX4B_ADDR	0xe9	/* Exit 4-byte address mode */
-
-/* N25Q Commands */
-/*	- READ with 32-bit addressing */
-#define N25Q_CMD_READ4			0x13
-#define N25Q_CMD_READ4_FAST		0x0c
-#define N25Q_CMD_READ4_1_1_2		0x3c
-#define N25Q_CMD_READ4_1_2_2		0xbc
-#define N25Q_CMD_READ4_1_1_4		0x6c
-#define N25Q_CMD_READ4_1_4_4		0xec
-/*	- READ/CLEAR Flags Status register */
-#define N25Q_CMD_RFSR			0x70
-#define N25Q_CMD_CLFSR			0x50
-
-/* MX25 Commands */
-/*	- Read Security Register (home of '4BYTE' status bit!) */
-#define MX25_CMD_RDSCUR			0x2B
-
-
 /* Status register */
 #define FLASH_STATUS_BUSY	0x01
 #define FLASH_STATUS_WEL	0x02
@@ -128,7 +94,6 @@
 #define FLASH_CAPS_SE_32K	0x00000008
 #define FLASH_CAPS_CE		0x00000010
 #define FLASH_CAPS_32BITADDR	0x00000020
-#define FLASH_CAPS_RESET	0x00000040
 
 #define FLASH_CAPS_DUAL		0x0000ff00
 #define FLASH_CAPS_READ_1_1_2	0x00000100
@@ -163,7 +128,7 @@
 } __attribute__((__packed__, aligned(4)));
 #define FSM_SEQ_SIZE			sizeof(struct fsm_seq)
 
-static struct fsm_seq fsm_seq_dummy = {
+static struct fsm_seq seq_dummy = {
 	.data_size = TRANSFER_SIZE(0),
 	.seq = {
 		FSM_INST_STOP,
@@ -173,7 +138,7 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_read_jedec = {
+static struct fsm_seq seq_read_jedec = {
 	.data_size = TRANSFER_SIZE(8),
 	.seq_opc[0] = (SEQ_OPC_PADS_1 |
 		       SEQ_OPC_CYCLES(8) |
@@ -189,7 +154,7 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_read_status_fifo = {
+static struct fsm_seq seq_read_status_fifo = {
 	.data_size = TRANSFER_SIZE(4),
 	.seq_opc[0] = (SEQ_OPC_PADS_1 |
 		       SEQ_OPC_CYCLES(8) |
@@ -205,7 +170,7 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_write_status = {
+static struct fsm_seq seq_write_status = {
 	.seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
 		       SEQ_OPC_OPCODE(FLASH_CMD_WREN) | SEQ_OPC_CSDEASSERT),
 	.seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
@@ -222,7 +187,7 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_wrvcr = {
+static struct fsm_seq seq_wrvcr = {
 	.seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
 		       SEQ_OPC_OPCODE(FLASH_CMD_WREN) | SEQ_OPC_CSDEASSERT),
 	.seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
@@ -239,8 +204,10 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_erase_sector = {
-	/* 'addr_cfg' configured during initialisation */
+static struct fsm_seq seq_erase_sector = {
+	.addr_cfg = (ADR_CFG_PADS_1_ADD1 |
+		     ADR_CFG_CYCLES_ADD1(24) |
+		     ADR_CFG_CSDEASSERT_ADD1),
 	.seq_opc = {
 		(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
 		 SEQ_OPC_OPCODE(FLASH_CMD_WREN) | SEQ_OPC_CSDEASSERT),
@@ -252,7 +219,6 @@
 		FSM_INST_CMD1,
 		FSM_INST_CMD2,
 		FSM_INST_ADD1,
-		FSM_INST_ADD2,
 		FSM_INST_STOP,
 	},
 	.seq_cfg = (SEQ_CFG_PADS_1 |
@@ -261,7 +227,7 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-static struct fsm_seq fsm_seq_erase_chip = {
+static struct fsm_seq seq_erase_chip = {
 	.seq_opc = {
 		(SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
 		 SEQ_OPC_OPCODE(FLASH_CMD_WREN) | SEQ_OPC_CSDEASSERT),
@@ -280,25 +246,11 @@
 		    SEQ_CFG_STARTSEQ),
 };
 
-/* Configure 'addr_cfg' according to addressing mode */
-static int configure_erasesec_seq(struct fsm_seq *seq, int use_32bit_addr)
-{
-	int addr1_cycles = use_32bit_addr ? 16 : 8;
-
-	seq->addr_cfg = (ADR_CFG_CYCLES_ADD1(addr1_cycles) |
-			 ADR_CFG_PADS_1_ADD1 |
-			 ADR_CFG_CYCLES_ADD2(16) |
-			 ADR_CFG_PADS_1_ADD2 |
-			 ADR_CFG_CSDEASSERT_ADD2);
-	return 0;
-}
-
-/* The following FSM sequences are configured during initialisation according to
- * the platform and device capabilities.
+/* Read/Write templates configured according to platform/device capabilities
+ * during initialisation
  */
-static struct fsm_seq fsm_seq_read;
-static struct fsm_seq fsm_seq_write;
-static struct fsm_seq fsm_seq_en32bitaddr;
+static struct fsm_seq seq_read;
+static struct fsm_seq seq_write;
 
 /*
  * Debug code for examining FSM sequences
@@ -327,14 +279,6 @@
 	[FLASH_CMD_WRITE_1_2_2]	= "WRITE_1_2_2",
 	[FLASH_CMD_WRITE_1_1_4]	= "WRITE_1_1_4",
 	[FLASH_CMD_WRITE_1_4_4] = "WRITE_1_4_4",
-	[FLASH_CMD_EN4B_ADDR]	= "EN4B_ADDR",
-	[FLASH_CMD_EX4B_ADDR]	= "EX4B_ADDR",
-	[N25Q_CMD_READ4]	= "READ4",
-	[N25Q_CMD_READ4_FAST]	= "READ4_FAST",
-	[N25Q_CMD_READ4_1_1_2]	= "READ4_1_1_2",
-	[N25Q_CMD_READ4_1_2_2]	= "READ4_1_2_2",
-	[N25Q_CMD_READ4_1_1_4]	= "READ4_1_1_4",
-	[N25Q_CMD_READ4_1_4_4]	= "READ4_1_4_4",
 };
 
 char *fsm_inst_strs[256] = {
@@ -493,7 +437,6 @@
 
 static int w25q_config(struct stm_spi_fsm *fsm, struct flash_info *info);
 static int n25q_config(struct stm_spi_fsm *fsm, struct flash_info *info);
-static int mx25_config(struct stm_spi_fsm *fsm, struct flash_info *info);
 
 static struct flash_info __devinitdata flash_types[] = {
 
@@ -515,19 +458,6 @@
 	{ "m25px32", 0x207116, 0,  64 * 1024,  64, M25PX_CAPS, 75, NULL},
 	{ "m25px64", 0x207117, 0,  64 * 1024, 128, M25PX_CAPS, 75, NULL},
 
-#define MX25_CAPS (FLASH_CAPS_READ_WRITE	| \
-		   FLASH_CAPS_READ_FAST		| \
-		   FLASH_CAPS_READ_1_1_2	| \
-		   FLASH_CAPS_READ_1_2_2	| \
-		   FLASH_CAPS_READ_1_1_4	| \
-		   FLASH_CAPS_READ_1_4_4	| \
-		   FLASH_CAPS_WRITE_1_4_4	| \
-		   FLASH_CAPS_SE_4K		| \
-		   FLASH_CAPS_SE_32K)
-	{ "mx25l25635e", 0xc22019, 0, 64*1024, 512,
-	  (MX25_CAPS | FLASH_CAPS_32BITADDR | FLASH_CAPS_RESET),
-	  70, mx25_config},
-
 #define N25Q_CAPS (FLASH_CAPS_READ_WRITE	| \
 		   FLASH_CAPS_READ_FAST		| \
 		   FLASH_CAPS_READ_1_1_2	| \
@@ -539,8 +469,6 @@
 		   FLASH_CAPS_WRITE_1_1_4	| \
 		   FLASH_CAPS_WRITE_1_4_4)
 	{ "n25q128", 0x20ba18, 0, 64 * 1024,  256, N25Q_CAPS, 108, n25q_config},
-	{ "n25q256", 0x20ba19, 0, 64 * 1024,  512,
-	  N25Q_CAPS | FLASH_CAPS_32BITADDR, 108, n25q_config},
 
 	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
 #define W25X_CAPS (FLASH_CAPS_READ_WRITE	| \
@@ -569,42 +497,6 @@
 	{     NULL,  0x000000, 0,         0,   0,       0, },
 };
 
-/*
- * SoC reset on 'boot-from-spi' systems
- *
- * Certain modes of operation cause the Flash device to enter a particular state
- * for a period of time (e.g. 'Erase Sector', 'Quad Enable', and 'Enter 32-bit
- * Addr' commands).  On boot-from-spi systems, it is important to consider what
- * happens if a warm reset occurs during this period.  The SPIBoot controller
- * assumes that Flash device is in its default reset state, 24-bit address mode,
- * and ready to accept commands.  This can be achieved using some form of
- * on-board logic/controller to force a device POR in response to a SoC-level
- * reset or by making use of the device reset signal if available (limited
- * number of devices only).
- *
- * Failure to take such precautions can cause problems following a warm reset.
- * For some operations (e.g. ERASE), there is little that can be done.  For
- * other modes of operation (e.g. 32-bit addressing), options are often
- * available that can help minimise the window in which a reset could cause a
- * problem.
- *
- */
-static int can_handle_soc_reset(struct stm_spi_fsm *fsm,
-				      struct flash_info *info)
-{
-	/* Reset signal is available on the board and supported by the device */
-	if (fsm->capabilities.reset_signal &&
-	    (fsm->capabilities.reset_signal &&
-	     (info->capabilities & FLASH_CAPS_RESET)))
-		return 1;
-
-	/* Board-level logic forces a power-on-reset */
-	if (fsm->capabilities.reset_por)
-		return 1;
-
-	/* Reset is not properly handled and may result in failure to reboot. */
-	return 0;
-}
 
 /* Parameters to configure a READ or WRITE FSM sequence */
 struct seq_rw_config {
@@ -621,7 +513,7 @@
 /* Default READ configurations, in order of preference */
 static struct seq_rw_config default_read_configs[] = {
 	{FLASH_CAPS_READ_1_4_4, FLASH_CMD_READ_1_4_4,	0, 4, 4, 0x00, 2, 4},
-	{FLASH_CAPS_READ_1_1_4, FLASH_CMD_READ_1_1_4,	0, 1, 4, 0x00, 0, 8},
+	{FLASH_CAPS_READ_1_1_4, FLASH_CMD_READ_1_1_4,	0, 1, 4, 0x00, 4, 0},
 	{FLASH_CAPS_READ_1_2_2, FLASH_CMD_READ_1_2_2,	0, 2, 2, 0x00, 4, 0},
 	{FLASH_CAPS_READ_1_1_2, FLASH_CMD_READ_1_1_2,	0, 1, 2, 0x00, 0, 8},
 	{FLASH_CAPS_READ_FAST,	FLASH_CMD_READ_FAST,	0, 1, 1, 0x00, 0, 8},
@@ -658,71 +550,85 @@
 }
 
 /* Configure a READ/WRITE sequence according to configuration parameters */
-static int configure_rw_seq(struct fsm_seq *seq, struct seq_rw_config *cfg,
-			    int use_32bit_addr)
+static int configure_rw_seq(struct fsm_seq *seq, struct seq_rw_config *cfg)
 {
 	int i;
-	int addr1_cycles, addr2_cycles;
 
 	memset(seq, 0x00, FSM_SEQ_SIZE);
 
 	i = 0;
-	/* Add READ/WRITE OPC  */
-	seq->seq_opc[i++] = (SEQ_OPC_PADS_1 |
-			     SEQ_OPC_CYCLES(8) |
-			     SEQ_OPC_OPCODE(cfg->cmd));
-
-	/* Add WREN OPC for a WRITE sequence */
+	/* Add WREN OPC if required */
 	if (cfg->write)
 		seq->seq_opc[i++] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
 				     SEQ_OPC_OPCODE(FLASH_CMD_WREN) |
 				     SEQ_OPC_CSDEASSERT);
 
-	/* Address configuration (24 or 32-bit addresses) */
-	addr1_cycles = use_32bit_addr ? 16 : 8;
-	addr1_cycles /= cfg->addr_pads;
-	addr2_cycles = 16 / cfg->addr_pads;
-	seq->addr_cfg = ((addr1_cycles & 0x3f) << 0 |	/* ADD1 cycles */
-			 (cfg->addr_pads - 1) << 6 |	/* ADD1 pads */
-			 (addr2_cycles & 0x3f) << 16 |	/* ADD2 cycles */
-			 ((cfg->addr_pads - 1) << 22));	/* ADD2 pads */
-
-	/* Data/Sequence configuration */
-	seq->seq_cfg = ((cfg->data_pads - 1) << 16 |
-			SEQ_CFG_STARTSEQ |
-			SEQ_CFG_CSDEASSERT);
-	if (!cfg->write)
-		seq->seq_cfg |= SEQ_CFG_READNOTWRITE;
-
-	/* Mode configuration (no. of pads taken from addr cfg) */
-	seq->mode = ((cfg->mode_data & 0xff) << 0 |	/* data */
-		     (cfg->mode_cycles & 0x3f) << 16 |	/* cycles */
-		     (cfg->addr_pads - 1) << 22);	/* pads */
-
-	/* Dummy configuration (no. of pads taken from addr cfg) */
-	seq->dummy = ((cfg->dummy_cycles & 0x3f) << 16 |	/* cycles */
-		      (cfg->addr_pads - 1) << 22);		/* pads */
+	/* Add READ/WRITE OPC  */
+	seq->seq_opc[i++] = (SEQ_OPC_PADS_1 |
+			     SEQ_OPC_CYCLES(8) |
+			     SEQ_OPC_OPCODE(cfg->cmd));
 
+	/* Address/MODE/DUMMY configuration */
+	switch (cfg->addr_pads) {
+	case (1):
+		seq->addr_cfg = (ADR_CFG_PADS_1_ADD1 | ADR_CFG_CYCLES_ADD1(24));
+		seq->mode = MODE_PADS_1;
+		seq->dummy = DUMMY_PADS_1;
+		break;
+	case (2):
+		seq->addr_cfg = (ADR_CFG_PADS_2_ADD1 | ADR_CFG_CYCLES_ADD1(12));
+		seq->mode = MODE_PADS_2;
+		seq->dummy = DUMMY_PADS_2;
+		break;
+	case (4):
+		seq->addr_cfg = (ADR_CFG_PADS_4_ADD1 | ADR_CFG_CYCLES_ADD1(6));
+		seq->mode = MODE_PADS_4;
+		seq->dummy = DUMMY_PADS_4;
+		break;
+	default:
+		return 1;
+		break;
+	}
 
-	/* Instruction sequence */
+	/* FSM instruction sequence */
 	i = 0;
+	seq->seq[i++] = FSM_INST_CMD1;
 	if (cfg->write)
 		seq->seq[i++] = FSM_INST_CMD2;
-
-	seq->seq[i++] = FSM_INST_CMD1;
-
 	seq->seq[i++] = FSM_INST_ADD1;
-	seq->seq[i++] = FSM_INST_ADD2;
 
-	if (cfg->mode_cycles)
+	if (cfg->mode_cycles) {
+		seq->mode |= (MODE_DATA(cfg->mode_data) |
+			      MODE_CYCLES(cfg->mode_cycles));
 		seq->seq[i++] = FSM_INST_MODE;
+	}
 
-	if (cfg->dummy_cycles)
+	if (cfg->dummy_cycles) {
+		seq->dummy |= DUMMY_CYCLES(cfg->dummy_cycles);
 		seq->seq[i++] = FSM_INST_DUMMY;
+	}
 
 	seq->seq[i++] = cfg->write ? FSM_INST_DATA_WRITE : FSM_INST_DATA_READ;
 	seq->seq[i++] = FSM_INST_STOP;
 
+	switch (cfg->data_pads) {
+	case (1):
+		seq->seq_cfg = SEQ_CFG_PADS_1;
+		break;
+	case (2):
+		seq->seq_cfg = SEQ_CFG_PADS_2;
+		break;
+	case (4):
+		seq->seq_cfg = SEQ_CFG_PADS_4;
+		break;
+	default:
+		return 1;
+		break;
+	}
+	if (!cfg->write)
+		seq->seq_cfg |= SEQ_CFG_READNOTWRITE;
+	seq->seq_cfg |= SEQ_CFG_STARTSEQ | SEQ_CFG_CSDEASSERT;
+
 	return 0;
 }
 
@@ -743,8 +649,7 @@
 		return 1;
 	}
 
-	if (configure_rw_seq(seq, config,
-			     capabilities & FLASH_CAPS_32BITADDR) != 0) {
+	if (configure_rw_seq(seq, config) != 0) {
 		dev_err(fsm->dev, "failed to configure READ/WRITE sequence\n");
 		return 1;
 	}
@@ -757,42 +662,35 @@
 static int fsm_write_status(struct stm_spi_fsm *fsm, uint16_t status,
 			    int sta_bytes);
 static int fsm_wrvcr(struct stm_spi_fsm *fsm, uint8_t data);
-static int fsm_enter_32bitaddr(struct stm_spi_fsm *fsm, int enter);
 
-/* [DEFAULT] Configure READ/WRITE/ERASE sequences */
-static int fsm_config_rwe_seqs_default(struct stm_spi_fsm *fsm,
+/* [DEFAULT] Configure READ/WRITE sequences */
+static int fsm_config_rw_seqs_default(struct stm_spi_fsm *fsm,
 				      struct flash_info *info)
 {
+	/* Set of mutually supported capabilities */
 	uint32_t capabilities = info->capabilities;
 
-	/* Mask-out capabilities not supported by platform */
 	if (fsm->capabilities.quad_mode == 0)
 		capabilities &= ~FLASH_CAPS_QUAD;
 	if (fsm->capabilities.dual_mode == 0)
 		capabilities &= ~FLASH_CAPS_DUAL;
+	if (fsm->capabilities.addr_32bit == 0)
+		capabilities &= ~FLASH_CAPS_32BITADDR;
 
-	/* Configure 'READ' sequence */
-	if (fsm_search_configure_rw_seq(fsm, &fsm_seq_read,
-					default_read_configs,
+	if (fsm_search_configure_rw_seq(fsm, &seq_read, default_read_configs,
 					capabilities) != 0) {
 		dev_err(fsm->dev, "failed to configure READ sequence "
 			"according to capabilities [0x%08x]\n", capabilities);
 		return 1;
 	}
 
-	/* Configure 'WRITE' sequence */
-	if (fsm_search_configure_rw_seq(fsm, &fsm_seq_write,
-					default_write_configs,
+	if (fsm_search_configure_rw_seq(fsm, &seq_write, default_write_configs,
 					capabilities) != 0) {
 		dev_err(fsm->dev, "failed to configure WRITE sequence "
 			"according to capabilities [0x%08x]\n", capabilities);
 		return 1;
 	}
 
-	/* Configure 'ERASE_SECTOR' sequence */
-	configure_erasesec_seq(&fsm_seq_erase_sector,
-			       capabilities & FLASH_CAPS_32BITADDR);
-
 	return 0;
 }
 
@@ -804,11 +702,11 @@
 	uint8_t sta1, sta2;
 	uint16_t sta_wr;
 
-	if (fsm_config_rwe_seqs_default(fsm, info) != 0)
+	if (fsm_config_rw_seqs_default(fsm, info) != 0)
 		return 1;
 
 	/* If using QUAD mode, set QE STATUS bit */
-	data_pads = ((fsm_seq_read.seq_cfg >> 16) & 0x3) + 1;
+	data_pads = ((seq_read.seq_cfg >> 16) & 0x3) + 1;
 	if (data_pads == 4) {
 		fsm_read_status(fsm, FLASH_CMD_RDSR, &sta1);
 		fsm_read_status(fsm, FLASH_CMD_RDSR2, &sta2);
@@ -823,225 +721,57 @@
 	return 0;
 }
 
-/* [MX25xxx] Configure READ/Write sequences */
-#define MX25_STATUS_QE			(0x1 << 6)
-
-static int mx25_configure_en32bitaddr_seq(struct fsm_seq *seq)
-{
-	seq->seq_opc[0] = (SEQ_OPC_PADS_1 |
-			   SEQ_OPC_CYCLES(8) |
-			   SEQ_OPC_OPCODE(FLASH_CMD_EN4B_ADDR) |
-			   SEQ_OPC_CSDEASSERT);
-
-	seq->seq[0] = FSM_INST_CMD1;
-	seq->seq[1] = FSM_INST_WAIT;
-	seq->seq[2] = FSM_INST_STOP;
-
-	seq->seq_cfg = (SEQ_CFG_PADS_1 |
-			SEQ_CFG_ERASE |
-			SEQ_CFG_READNOTWRITE |
-			SEQ_CFG_CSDEASSERT |
-			SEQ_CFG_STARTSEQ);
-
-	return 0;
-}
-
-static int mx25_config(struct stm_spi_fsm *fsm, struct flash_info *info)
-{
-	uint32_t data_pads;
-	uint8_t sta;
-
-	/* Disable support for 'WRITE_1_4_4' (limited to 20MHz which is of
-	 * marginal benefit on our hardware and doesn't justify implementing
-	 * different READ/WRITE frequencies).
-	 */
-	info->capabilities &= ~FLASH_CAPS_WRITE_1_4_4;
-
-	/*
-	 * Use default READ/WRITE sequences
-	 */
-	if (fsm_config_rwe_seqs_default(fsm, info) != 0)
-		return 1;
-
-	/*
-	 * Configure 32-bit Address Support
-	 */
-	if (info->capabilities & FLASH_CAPS_32BITADDR) {
-		/* Configure 'enter_32bitaddr' FSM sequence */
-		mx25_configure_en32bitaddr_seq(&fsm_seq_en32bitaddr);
-
-		if (!fsm->capabilities.boot_from_spi ||
-		    can_handle_soc_reset(fsm, info)) {
-			/* If we can handle SoC resets, we enable 32-bit address
-			 * mode pervasively */
-			fsm_enter_32bitaddr(fsm, 1);
-
-		} else {
-			/* Else, enable/disable 32-bit addressing before/after
-			 * each operation */
-			fsm->configuration = (CFG_READ_TOGGLE32BITADDR |
-					      CFG_WRITE_TOGGLE32BITADDR |
-					      CFG_ERASESEC_TOGGLE32BITADDR);
-			/* It seems a small delay is required after exiting
-			 * 32-bit mode following a write operation.  The issue
-			 * is under investigation.
-			 */
-			fsm->configuration |= CFG_WRITE_EX32BITADDR_DELAY;
-		}
-	}
-
-	/* For QUAD mode, set 'QE' STATUS bit */
-	data_pads = ((fsm_seq_read.seq_cfg >> 16) & 0x3) + 1;
-	if (data_pads == 4) {
-		fsm_read_status(fsm, FLASH_CMD_RDSR, &sta);
-		sta |= MX25_STATUS_QE;
-		fsm_write_status(fsm, sta, 1);
-	}
-
-	return 0;
-}
-
-/*
- * [N25Qxxx] Configuration
- */
+/* [N25Qxxx] Configure READ/WRITE sequences */
 #define N25Q_VCR_DUMMY_CYCLES(x)	(((x) & 0xf) << 4)
 #define N25Q_VCR_XIP_DISABLED		((uint8_t)0x1 << 3)
-#define N25Q_VCR_WRAP_CONT		0x3
-
-/* N25Q 3-byte Address READ configurations
- *	- 'FAST' variants configured for 8 dummy cycles.
- *
- * Note, the number of dummy cycles used for 'FAST' READ operations is
- * configurable and would normally be tuned according to the READ command and
- * operating frequency.  However, this applies universally to all 'FAST' READ
- * commands, including those used by the SPIBoot controller, and remains in
- * force until the device is power-cycled.  Since the SPIBoot controller is
- * hard-wired to use 8 dummy cycles, we must configure the device to also use 8
- * cycles.
- */
-static struct seq_rw_config n25q_read3_configs[] = {
-	{FLASH_CAPS_READ_1_4_4, FLASH_CMD_READ_1_4_4,	0, 4, 4, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_1_4, FLASH_CMD_READ_1_1_4,	0, 1, 4, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_2_2, FLASH_CMD_READ_1_2_2,	0, 2, 2, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_1_2, FLASH_CMD_READ_1_1_2,	0, 1, 2, 0x00, 0, 8},
-	{FLASH_CAPS_READ_FAST,	FLASH_CMD_READ_FAST,	0, 1, 1, 0x00, 0, 8},
-	{FLASH_CAPS_READ_WRITE, FLASH_CMD_READ,	        0, 1, 1, 0x00, 0, 0},
-	{0x00,			 0,			0, 0, 0, 0x00, 0, 0},
-};
-
-/* N25Q 4-byte Address READ configurations
- *	- use special 4-byte address READ commands (reduces overheads, and
- *        reduces risk of hitting watchdog resets issues).
- *	- 'FAST' variants configured for 8 dummy cycles (see note above.)
- */
-static struct seq_rw_config n25q_read4_configs[] = {
-	{FLASH_CAPS_READ_1_4_4, N25Q_CMD_READ4_1_4_4,	0, 4, 4, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_1_4, N25Q_CMD_READ4_1_1_4,	0, 1, 4, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_2_2, N25Q_CMD_READ4_1_2_2,	0, 2, 2, 0x00, 0, 8},
-	{FLASH_CAPS_READ_1_1_2, N25Q_CMD_READ4_1_1_2,	0, 1, 2, 0x00, 0, 8},
-	{FLASH_CAPS_READ_FAST,	N25Q_CMD_READ4_FAST,	0, 1, 1, 0x00, 0, 8},
-	{FLASH_CAPS_READ_WRITE, N25Q_CMD_READ4,		0, 1, 1, 0x00, 0, 0},
-	{0x00,			 0,			0, 0, 0, 0x00, 0, 0},
-};
-
-static int n25q_configure_en32bitaddr_seq(struct fsm_seq *seq)
-{
-	seq->seq_opc[0] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
-			   SEQ_OPC_OPCODE(FLASH_CMD_EN4B_ADDR));
-	seq->seq_opc[1] = (SEQ_OPC_PADS_1 | SEQ_OPC_CYCLES(8) |
-			   SEQ_OPC_OPCODE(FLASH_CMD_WREN) |
-			   SEQ_OPC_CSDEASSERT);
-
-	seq->seq[0] = FSM_INST_CMD2;
-	seq->seq[1] = FSM_INST_CMD1;
-	seq->seq[2] = FSM_INST_WAIT;
-	seq->seq[3] = FSM_INST_STOP;
-
-	seq->seq_cfg = (SEQ_CFG_PADS_1 |
-			SEQ_CFG_ERASE |
-			SEQ_CFG_READNOTWRITE |
-			SEQ_CFG_CSDEASSERT |
-			SEQ_CFG_STARTSEQ);
-
-	return 0;
-}
-
 static int n25q_config(struct stm_spi_fsm *fsm, struct flash_info *info)
 {
+	uint8_t read_cmd;
 	uint8_t vcr;
 	int ret = 0;
-	uint32_t capabilities = info->capabilities;
+	uint8_t dummy_cycles;
 
-	/* Mask out-capabilities not supported by platform */
-	if (fsm->capabilities.quad_mode == 0)
-		capabilities &= ~FLASH_CAPS_QUAD;
-	if (fsm->capabilities.dual_mode == 0)
-		capabilities &= ~FLASH_CAPS_DUAL;
-
-	/*
-	 * Configure 'READ' sequence
-	 */
-	if (capabilities & FLASH_CAPS_32BITADDR)
-		/* 32-bit addressing supported by N25Q 'READ4' commands */
-		ret = fsm_search_configure_rw_seq(fsm, &fsm_seq_read,
-						  n25q_read4_configs,
-						  capabilities);
-	else
-		/* 24-bit addressing with 8 dummy cycles */
-		ret = fsm_search_configure_rw_seq(fsm, &fsm_seq_read,
-						  n25q_read3_configs,
-						  capabilities);
-
-	if (ret != 0) {
-		dev_err(fsm->dev, "failed to configure READ sequence "
-			"according to capabilities [0x%08x]\n", capabilities);
+	ret = fsm_config_rw_seqs_default(fsm, info);
+	if (ret != 0)
 		return 1;
-	}
-
 
-	/*
-	 * Configure 'WRITE' sequence (use default configs)
+	/* The number of dummy cycles is configurable (tuned according to the
+	 * READ command and operating frequency), but applies universally across
+	 * all variants of READ command that make use of dummy cycles.  However,
+	 * the SPIBoot controller is hard-wired to use 8 dummy cycles for FAST
+	 * READ, and DUAL OUTPUT READ.  To ensure the SPIBoot controller can
+	 * operate in these modes (e.g. following a watchdog reset) we configure
+	 * the device to use 8 dummy cycles, and update the FSM read sequence if
+	 * necessary.
 	 */
-	ret = fsm_search_configure_rw_seq(fsm, &fsm_seq_write,
-					  default_write_configs,
-					  capabilities);
-	if (ret != 0) {
-		dev_err(fsm->dev, "failed to configure WRITE sequence "
-			"according to capabilities [0x%08x]\n", capabilities);
-		return 1;
+	dummy_cycles = 8;
+	read_cmd = (uint8_t)(seq_read.seq_opc[0] & 0xff);
+	switch (read_cmd) {
+	case FLASH_CMD_READ_1_4_4:
+		ret = configure_rw_seq(&seq_read, &(struct seq_rw_config) {
+				.cmd = FLASH_CMD_READ_1_4_4,
+				.addr_pads = 4,
+				.data_pads = 4,
+				.dummy_cycles = dummy_cycles});
+		break;
+	case FLASH_CMD_READ_1_1_4:
+		ret = configure_rw_seq(&seq_read, &(struct seq_rw_config) {
+				.cmd = FLASH_CMD_READ_1_1_4,
+				.addr_pads = 1,
+				.data_pads = 4,
+				.dummy_cycles = dummy_cycles});
+		break;
+	case FLASH_CMD_READ_1_2_2:
+		ret = configure_rw_seq(&seq_read, &(struct seq_rw_config) {
+				.cmd = FLASH_CMD_READ_1_2_2,
+				.addr_pads = 2,
+				.data_pads = 2,
+				.dummy_cycles = dummy_cycles});
+		break;
 	}
 
-	/*
-	 * Configure 'ERASE_SECTOR' sequence
-	 */
-	configure_erasesec_seq(&fsm_seq_erase_sector,
-			       capabilities & FLASH_CAPS_32BITADDR);
-
-	/*
-	 * Configure 32-bit address support
-	 */
-	if (capabilities & FLASH_CAPS_32BITADDR) {
-		/* Configure 'enter_32bitaddr' FSM sequence */
-		n25q_configure_en32bitaddr_seq(&fsm_seq_en32bitaddr);
-
-		if (!fsm->capabilities.boot_from_spi ||
-		    can_handle_soc_reset(fsm, info)) {
-			/* If we can handle SoC resets, we enable 32-bit address
-			 * mode pervasively */
-			fsm_enter_32bitaddr(fsm, 1);
-		} else {
-			/* Else, enable/disable for WRITE and ERASE operations
-			 * (READ uses special commands) */
-			fsm->configuration = (CFG_WRITE_TOGGLE32BITADDR |
-					      CFG_ERASESEC_TOGGLE32BITADDR);
-		}
-	}
+	vcr = N25Q_VCR_DUMMY_CYCLES(dummy_cycles) | N25Q_VCR_XIP_DISABLED;
 
-	/*
-	 * Configure device to use 8 dummy cycles
-	 */
-	vcr = (N25Q_VCR_DUMMY_CYCLES(8) | N25Q_VCR_XIP_DISABLED |
-	       N25Q_VCR_WRAP_CONT);
 	fsm_wrvcr(fsm, vcr);
 
 	return ret;
@@ -1143,7 +873,7 @@
  */
 static int fsm_wait_busy(struct stm_spi_fsm *fsm)
 {
-	struct fsm_seq *seq = &fsm_seq_read_status_fifo;
+	struct fsm_seq *seq = &seq_read_status_fifo;
 	unsigned long deadline;
 	uint8_t status[4] = {0x00, 0x00, 0x00, 0x00};
 
@@ -1160,10 +890,10 @@
 	do {
 		cond_resched();
 
-		fsm_wait_seq(fsm);
-
 		fsm_read_fifo(fsm, (uint32_t *)status, 4);
 
+		fsm_wait_seq(fsm);
+
 		if ((status[3] & FLASH_STATUS_BUSY) == 0)
 			return 0;
 
@@ -1179,7 +909,7 @@
 
 static int fsm_read_jedec(struct stm_spi_fsm *fsm, uint8_t *const jedec)
 {
-	const struct fsm_seq *seq = &fsm_seq_read_jedec;
+	const struct fsm_seq *seq = &seq_read_jedec;
 	uint32_t tmp[2];
 
 	fsm_load_seq(fsm, seq);
@@ -1194,7 +924,7 @@
 static int fsm_read_status(struct stm_spi_fsm *fsm, uint8_t cmd,
 			   uint8_t *status)
 {
-	struct fsm_seq *seq = &fsm_seq_read_status_fifo;
+	struct fsm_seq *seq = &seq_read_status_fifo;
 	uint32_t tmp;
 
 	dev_dbg(fsm->dev, "reading STA[%s]\n",
@@ -1218,7 +948,7 @@
 static int fsm_write_status(struct stm_spi_fsm *fsm, uint16_t status,
 			    int sta_bytes)
 {
-	struct fsm_seq *seq = &fsm_seq_write_status;
+	struct fsm_seq *seq = &seq_write_status;
 
 	dev_dbg(fsm->dev, "writing STA[%s] 0x%04x\n",
 		(sta_bytes == 1) ? "1" : "1+2", status);
@@ -1235,7 +965,7 @@
 
 static int fsm_wrvcr(struct stm_spi_fsm *fsm, uint8_t data)
 {
-	struct fsm_seq *seq = &fsm_seq_wrvcr;
+	struct fsm_seq *seq = &seq_wrvcr;
 
 	dev_dbg(fsm->dev, "writing VCR 0x%02x\n", data);
 
@@ -1249,36 +979,13 @@
 	return 0;
 }
 
-static int fsm_enter_32bitaddr(struct stm_spi_fsm *fsm, int enter)
-{
-	struct fsm_seq *seq = &fsm_seq_en32bitaddr;
-	uint32_t cmd = enter ? FLASH_CMD_EN4B_ADDR : FLASH_CMD_EX4B_ADDR;
-
-	seq->seq_opc[0] = (SEQ_OPC_PADS_1 |
-			   SEQ_OPC_CYCLES(8) |
-			   SEQ_OPC_OPCODE(cmd) |
-			   SEQ_OPC_CSDEASSERT);
-
-	fsm_load_seq(fsm, seq);
-
-	fsm_wait_seq(fsm);
-
-	return 0;
-}
-
-
 static int fsm_erase_sector(struct stm_spi_fsm *fsm, const uint32_t offset)
 {
-	struct fsm_seq *seq = &fsm_seq_erase_sector;
+	struct fsm_seq *seq = &seq_erase_sector;
 
 	dev_dbg(fsm->dev, "erasing sector at 0x%08x\n", offset);
 
-	/* Enter 32-bit address mode, if required */
-	if (fsm->configuration & CFG_ERASESEC_TOGGLE32BITADDR)
-		fsm_enter_32bitaddr(fsm, 1);
-
-	seq->addr1 = (offset >> 16) & 0xffff;
-	seq->addr2 = offset & 0xffff;
+	seq->addr1 = offset;
 
 	fsm_load_seq(fsm, seq);
 
@@ -1286,16 +993,12 @@
 
 	fsm_wait_busy(fsm);
 
-	/* Exit 32-bit address mode, if required */
-	if (fsm->configuration & CFG_ERASESEC_TOGGLE32BITADDR)
-		fsm_enter_32bitaddr(fsm, 0);
-
 	return 0;
 }
 
 static int fsm_erase_chip(struct stm_spi_fsm *fsm)
 {
-	const struct fsm_seq *seq = &fsm_seq_erase_chip;
+	const struct fsm_seq *seq = &seq_erase_chip;
 
 	dev_dbg(fsm->dev, "erasing chip\n");
 
@@ -1311,7 +1014,7 @@
 static int fsm_read(struct stm_spi_fsm *fsm, uint8_t *const buf,
 		    const uint32_t size, const uint32_t offset)
 {
-	struct fsm_seq *seq = &fsm_seq_read;
+	struct fsm_seq *seq = &seq_read;
 	uint32_t data_pads;
 	uint32_t read_mask;
 	uint8_t *page_buf = fsm->page_buf;
@@ -1323,10 +1026,6 @@
 
 	dev_dbg(fsm->dev, "reading %d bytes from 0x%08x\n", size, offset);
 
-	/* Enter 32-bit address mode, if required */
-	if (fsm->configuration & CFG_READ_TOGGLE32BITADDR)
-		fsm_enter_32bitaddr(fsm, 1);
-
 	/* Must read in multiples of 32 cycles (or 32*pads/8 bytes) */
 	data_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;
 	read_mask = (data_pads << 2) - 1;
@@ -1340,8 +1039,7 @@
 	size_mop = size & read_mask;
 
 	seq->data_size = TRANSFER_SIZE(size_ub);
-	seq->addr1 = (offset >> 16) & 0xffff;
-	seq->addr2 = offset & 0xffff;
+	seq->addr1 = offset;
 
 	fsm_load_seq(fsm, seq);
 
@@ -1362,17 +1060,13 @@
 
 	fsm_clear_fifo(fsm);
 
-	/* Exit 32-bit address mode, if required */
-	if (fsm->configuration & CFG_READ_TOGGLE32BITADDR)
-		fsm_enter_32bitaddr(fsm, 0);
-
 	return 0;
 }
 
 static int fsm_write(struct stm_spi_fsm *fsm, const uint8_t *const buf,
 		     const uint32_t size, const uint32_t offset)
 {
-	struct fsm_seq *seq = &fsm_seq_write;
+	struct fsm_seq *seq = &seq_write;
 	uint32_t data_pads;
 	uint32_t write_mask;
 	uint8_t *page_buf = fsm->page_buf;
@@ -1386,10 +1080,6 @@
 
 	dev_dbg(fsm->dev, "writing %d bytes to 0x%08x\n", size, offset);
 
-	/* Enter 32-bit address mode, if required */
-	if (fsm->configuration & CFG_WRITE_TOGGLE32BITADDR)
-		fsm_enter_32bitaddr(fsm, 1);
-
 	/* Must write in multiples of 32 cycles (or 32*pads/8 bytes) */
 	data_pads = ((seq->seq_cfg >> 16) & 0x3) + 1;
 	write_mask = (data_pads << 2) - 1;
@@ -1408,11 +1098,10 @@
 	size_mop = size & write_mask;
 
 	seq->data_size = TRANSFER_SIZE(size_ub);
-	seq->addr1 = (offset >> 16) & 0xffff;
-	seq->addr2 = offset & 0xffff;
+	seq->addr1 = offset;
 
 	if (fsm->capabilities.dummy_on_write) {
-		fsm_load_seq(fsm, &fsm_seq_dummy);
+		fsm_load_seq(fsm, &seq_dummy);
 		readl(fsm->base + SPI_FAST_SEQ_CFG);
 	}
 
@@ -1420,15 +1109,7 @@
 	 * GNBvb79594)
 	 */
 	writel(0x00040000, fsm->base + SPI_FAST_SEQ_CFG);
-
-	/*
-	 * Before writing data to the FIFO, apply a small delay to allow a
-	 * potential change of FIFO direction to complete.
-	 */
-	if (fsm->fifo_dir_delay == 0)
-		readl(fsm->base + SPI_FAST_SEQ_CFG);
-	else
-		udelay(fsm->fifo_dir_delay);
+	readl(fsm->base + SPI_FAST_SEQ_CFG);
 
 	/* Write data to FIFO, before starting sequence (see GNBvd79593) */
 	if (size_lb) {
@@ -1454,13 +1135,6 @@
 	/* Wait for completion */
 	fsm_wait_busy(fsm);
 
-	/* Exit 32-bit address mode, if required */
-	if (fsm->configuration & CFG_WRITE_TOGGLE32BITADDR) {
-		fsm_enter_32bitaddr(fsm, 0);
-		if (fsm->configuration & CFG_WRITE_EX32BITADDR_DELAY)
-			udelay(1);
-	}
-
 	return 0;
 }
 
@@ -1509,19 +1183,6 @@
 	else if (clk_div > 128)
 		clk_div = 128;
 
-	/*
-	 * Determine a suitable delay for the IP to complete a change of
-	 * direction of the FIFO.  The required delay is related to the clock
-	 * divider used.  The following heuristics are based on empirical tests,
-	 * using a 100MHz EMI clock.
-	 */
-	if (clk_div <= 4)
-		fsm->fifo_dir_delay = 0;
-	else if (clk_div <= 10)
-		fsm->fifo_dir_delay = 1;
-	else
-		fsm->fifo_dir_delay = (clk_div + 9) / 10;
-
 	dev_dbg(fsm->dev, "emi_clk = %uHZ, spi_freq = %uHZ, clock_div = %u\n",
 		emi_freq, freq, clk_div);
 
@@ -1761,7 +1422,6 @@
 	return NULL;
 }
 
-
 /*
  * STM SPI FSM driver setup
  */
@@ -1811,15 +1471,6 @@
 		goto out2;
 	}
 
-	if (data->pads) {
-		fsm->pad_state = stm_pad_claim(data->pads, pdev->name);
-		if (!fsm->pad_state) {
-			dev_err(&pdev->dev, "failed to request pads\n");
-			ret = -EBUSY;
-			goto out3;
-		}
-	}
-
 	mutex_init(&fsm->lock);
 
 	/* Initialise FSM */
@@ -1828,49 +1479,34 @@
 		dev_err(&pdev->dev, "failed to initialise SPI FSM "
 			"Controller\n");
 		ret = -EINVAL;
-		goto out4;
+		goto out3;
 	}
 
 	/* Detect SPI FLASH device */
 	info = fsm_jedec_probe(fsm);
 	if (!info) {
 		ret = -ENODEV;
-		goto out5;
+		goto out4;
 	}
 
-	/*
-	 * Issue warning if device found does not match that specified in the
-	 * platform data.
-	 */
-	if (data->name && strcmp(data->name, info->name) != 0)
-		dev_warn(&pdev->dev, "WARNING: expecting '%s', found '%s'\n",
-			 data->name, info->name);
-
-	/* Configure READ/WRITE/ERASE sequences according to platform and device
+	/* Configure READ/WRITE sequences according to platform and device
 	 * capabilities.
 	 */
 	if (info->config) {
 		if (info->config(fsm, info) != 0) {
 			ret = -EINVAL;
-			goto out5;
+			goto out4;
 		}
 	} else {
-		if (fsm_config_rwe_seqs_default(fsm, info) != 0) {
+		if (fsm_config_rw_seqs_default(fsm, info) != 0) {
 			ret = -EINVAL;
-			goto out5;
+			goto out4;
 		}
 	}
 
-	if (fsm->capabilities.boot_from_spi &&
-	    !can_handle_soc_reset(fsm, info))
-		dev_warn(&pdev->dev, "WARNING: no provision for SPI reset"
-			 "on boot-from-spi system\n");
-
 #ifdef DEBUG_SPI_FSM_SEQS
-	fsm_dump_seq("FSM READ SEQ", &fsm_seq_read);
-	fsm_dump_seq("FSM WRITE_SEQ", &fsm_seq_write);
-	fsm_dump_seq("FSM ERASE_SECT_SEQ", &fsm_seq_erase_sector);
-	fsm_dump_seq("FSM EN32BITADDR_SEQ", &fsm_seq_en32bitaddr);
+	fsm_dump_seq("FSM READ SEQ", &seq_read);
+	fsm_dump_seq("FSM WRITE_SEQ", &seq_write);
 #endif
 
 	platform_set_drvdata(pdev, fsm);
@@ -1904,15 +1540,6 @@
 		 (long long)fsm->mtd.size, (long long)(fsm->mtd.size >> 20),
 		 fsm->mtd.erasesize, (fsm->mtd.erasesize >> 10));
 
-	/* Cap size to 16MiB if 32-bit addressing is not supported/implemented
-	 * on specific device */
-	if ((fsm->mtd.size > 16 * 1024 * 1024)  &&
-	    ((info->capabilities & FLASH_CAPS_32BITADDR) == 0)) {
-		dev_info(&pdev->dev, "reducing visibility to 16MiB "
-			 "(32-bit address mode not supported on device)\n");
-		fsm->mtd.size = 16 * 1024 * 1024;
-	}
-
 	/* Add partitions */
 	if (mtd_has_partitions()) {
 		struct mtd_partition	*parts = NULL;
@@ -1945,7 +1572,7 @@
 
 			if (add_mtd_partitions(&fsm->mtd, parts, nr_parts)) {
 				ret = -ENODEV;
-				goto out5;
+				goto out4;
 			}
 
 			/* Success :-) */
@@ -1959,17 +1586,15 @@
 
 	if (add_mtd_device(&fsm->mtd)) {
 		ret = -ENODEV;
-		goto out5;
+		goto out4;
 	}
 
 	/* Success :-) */
 	return 0;
- out5:
+
+ out4:
 	fsm_exit(fsm);
 	platform_set_drvdata(pdev, NULL);
- out4:
-	if (fsm->pad_state)
-		stm_pad_release(fsm->pad_state);
  out3:
 	iounmap(fsm->base);
  out2:
@@ -1990,8 +1615,6 @@
 		del_mtd_device(&fsm->mtd);
 
 	fsm_exit(fsm);
-	if (fsm->pad_state)
-		stm_pad_release(fsm->pad_state);
 	iounmap(fsm->base);
 	release_resource(fsm->region);
 	platform_set_drvdata(pdev, NULL);
--- a/drivers/mtd/maps/Kconfig	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/maps/Kconfig	2009-12-03 04:51:21.000000000 +0100
@@ -9,16 +9,6 @@
 	  This causes the chip drivers to allow for complicated
 	  paged mappings of flash chips.
 
-config MTD_STM_EMI_WRITEPRO_MAP
-	bool "STMicroelectronics EMI 'Write-Protect' Mapping"
-	depends on MTD_COMPLEX_MAPPINGS
-	help
-	  Add support for a 'Write-Protect' mapping of an STM EMI bank.  The
-	  mapping, which can be used in conjunction with the Physmap driver,
-	  disables the EMI 'write-CS' when not required by the driver.  This
-	  provides some level of protection against rogue accesses to the EMI
-	  bank.
-
 config MTD_PHYSMAP
 	tristate "Flash device in physical memory map"
 	depends on MTD_CFI || MTD_JEDECPROBE || MTD_ROM || MTD_LPDDR
--- a/drivers/mtd/maps/Makefile	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/maps/Makefile	2009-12-03 04:51:21.000000000 +0100
@@ -61,4 +61,3 @@
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
 obj-$(CONFIG_MTD_GPIO_ADDR)	+= gpio-addr-flash.o
-obj-$(CONFIG_MTD_STM_EMI_WRITEPRO_MAP) += stm_emi_wp_map.o
--- a/drivers/mtd/maps/physmap.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/maps/physmap.c	2009-12-03 04:51:21.000000000 +0100
@@ -134,11 +134,6 @@
 			goto err_out;
 		}
 
-#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-		if (physmap_data->map_init)
-			physmap_data->map_init(&info->map[i]);
-		else
-#endif
 		simple_map_init(&info->map[i]);
 
 		probe_type = rom_probe_types;
--- a/drivers/mtd/maps/stm_emi_wp_map.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/maps/stm_emi_wp_map.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,75 +0,0 @@
-/*
- * drivers/mtd/maps/stm_emi_wp_map.c: STMicroelectronics EMI 'Write-Protect'
- * Mapping
- *
- * Mapping functions based on drivers/mtd/maps/map_funcs.c, modified to enable
- * the EMI 'write-CS' only when a write operation is requested by the mapping
- * driver.  This limits the window in which a rogue initiator can write to the
- * EMI bank.
- *
- * Copyright (C) 2011 STMicroelectronics Limited
- *
- * May be copied or modified under the terms of the GNU General Public License.
- * See linux/COPYING for more information.
- */
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/mtd/map.h>
-#include <linux/mtd/xip.h>
-#include <linux/stm/emi.h>
-
-static map_word __xipram emi_map_read(struct map_info *map, unsigned long ofs)
-{
-	return inline_map_read(map, ofs);
-}
-
-static void __xipram emi_map_write(struct map_info *map, const map_word datum,
-				   unsigned long ofs)
-{
-	emi_bank_write_cs_enable(map->map_priv_1, 1);
-	inline_map_write(map, datum, ofs);
-	emi_bank_write_cs_enable(map->map_priv_1, 0);
-}
-
-static void __xipram emi_map_copy_from(struct map_info *map, void *to,
-				       unsigned long from, ssize_t len)
-{
-	inline_map_copy_from(map, to, from, len);
-}
-
-static void __xipram emi_map_copy_to(struct map_info *map, unsigned long to,
-				     const void *from, ssize_t len)
-{
-	emi_bank_write_cs_enable(map->map_priv_1, 1);
-	inline_map_copy_to(map, to, from, len);
-	emi_bank_write_cs_enable(map->map_priv_1, 0);
-}
-
-void stm_emi_map_init(struct map_info *map)
-{
-	int bank;
-
-	BUG_ON(!map_bankwidth_supported(map->bankwidth));
-
-	/* Find the EMI bank number over which the map is defined (assumes a
-	 * single bank per device).
-	 */
-	for (bank = 0; bank < EMI_BANKS; bank++) {
-		if (emi_bank_base(bank) == map->phys) {
-			map->map_priv_1 = bank;
-			break;
-		}
-	}
-	BUG_ON(bank == EMI_BANKS);
-
-	emi_bank_write_cs_enable(map->map_priv_1, 0);
-
-	map->read = emi_map_read;
-	map->write = emi_map_write;
-	map->copy_from = emi_map_copy_from;
-	map->copy_to = emi_map_copy_to;
-}
-EXPORT_SYMBOL(stm_emi_map_init);
-
-MODULE_LICENSE("GPL");
--- a/drivers/mtd/mtdchar.c	2012-12-23 15:47:29.000000000 +0100
+++ b/drivers/mtd/mtdchar.c	2009-12-03 04:51:21.000000000 +0100
@@ -290,7 +290,6 @@
 			ops.mode = MTD_OOB_RAW;
 			ops.datbuf = kbuf;
 			ops.oobbuf = NULL;
-			ops.ooboffs = 0;
 			ops.len = len;
 
 			ret = mtd->write_oob(mtd, *ppos, &ops);
--- a/drivers/mtd/nand/Kconfig	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/Kconfig	2012-11-11 01:39:29.000000000 +0100
@@ -482,18 +482,6 @@
 	  This enables the driver for the NAND Flash on evaluation board based
 	  on w90p910.
 
-config MTD_NAND_STM_BCH
-	tristate "STMicroelectronics: NANDi BCH Controller"
-	help
-	  Adds support for the STMicroelectronics NANDi BCH Controller
-
-config STM_NAND_BCH_DEBUG
-	bool "NANDi BCH debug messages"
-	depends on MTD_NAND_STM_BCH
-	default n
-	help
-	  Display debug messages on the console
-
 config MTD_NAND_STM_EMI
 	tristate "STMicroelectronics: EMI 'bit-banging'"
 	depends on MTD_NAND
--- a/drivers/mtd/nand/Makefile	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/Makefile	2012-11-11 01:39:29.000000000 +0100
@@ -42,7 +42,6 @@
 obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
-obj-$(CONFIG_MTD_NAND_STM_BCH)          += stm_nand_bch.o
 obj-$(CONFIG_MTD_NAND_STM_EMI)		+= stm_nand_emi.o
 obj-$(CONFIG_MTD_NAND_STM_FLEX)		+= stm_nand_flex.o stm_nand_ecc.o
 obj-$(CONFIG_MTD_NAND_STM_AFM)          += stm_nand_afm.o stm_nand_ecc.o
--- a/drivers/mtd/nand/nand_base.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/nand_base.c	2012-11-11 01:39:29.000000000 +0100
@@ -57,8 +57,7 @@
 struct dentry *file_erasebb;
 #endif
 
-u8 nand_erasebb;
-EXPORT_SYMBOL_GPL(nand_erasebb);
+u8 erasebb;
 
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
@@ -2473,7 +2472,7 @@
 		/*
 		 * heck if we have a bad block, we do not erase bad blocks !
 		 */
-		if (!nand_erasebb &&
+		if (!erasebb &&
 		    nand_block_checkbad(mtd, ((loff_t) page) <<
 					chip->page_shift, 0, allowbbt)) {
 			printk(KERN_WARNING "%s: attempt to erase a bad block "
@@ -2583,7 +2582,7 @@
  *
  * Sync is actually a wait for chip ready function
  */
-void nand_sync(struct mtd_info *mtd)
+static void nand_sync(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2594,7 +2593,6 @@
 	/* Release it and go back */
 	nand_release_device(mtd);
 }
-EXPORT_SYMBOL_GPL(nand_sync);
 
 /**
  * nand_block_isbad - [MTD Interface] Check if block at offset is bad
@@ -2634,19 +2632,18 @@
  * nand_suspend - [MTD Interface] Suspend the NAND flash
  * @mtd:	MTD device structure
  */
-int nand_suspend(struct mtd_info *mtd)
+static int nand_suspend(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
 	return nand_get_device(chip, mtd, FL_PM_SUSPENDED);
 }
-EXPORT_SYMBOL_GPL(nand_suspend);
 
 /**
  * nand_resume - [MTD Interface] Resume the NAND flash
  * @mtd:	MTD device structure
  */
-void nand_resume(struct mtd_info *mtd)
+static void nand_resume(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
 
@@ -2656,7 +2653,6 @@
 		printk(KERN_ERR "%s called for a chip which is not "
 		       "in suspended state\n", __func__);
 }
-EXPORT_SYMBOL_GPL(nand_resume);
 
 /*
  * Set default functions
@@ -2703,137 +2699,6 @@
 }
 
 /*
- * sanitize ONFI strings so we can safely print them
- */
-static void sanitize_string(uint8_t *s, size_t len)
-{
-	ssize_t i;
-
-	/* null terminate */
-	s[len - 1] = 0;
-
-	/* remove non printable chars */
-	for (i = 0; i < len - 1; i++) {
-		if (s[i] < ' ' || s[i] > 127)
-			s[i] = '?';
-	}
-
-	/* remove trailing spaces */
-	s = strstrip(s);
-}
-
-static u16 onfi_crc16(u16 crc, u8 const *p, size_t len)
-{
-	int i;
-	while (len--) {
-		crc ^= *p++ << 8;
-		for (i = 0; i < 8; i++)
-			crc = (crc << 1) ^ ((crc & 0x8000) ? 0x8005 : 0);
-	}
-
-	return crc;
-}
-
-/*
- * Check if the NAND chip is ONFI compliant, returns 1 if it is, 0 otherwise
- */
-static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
-					int busw)
-{
-	struct nand_onfi_params *p = &chip->onfi_params;
-	uint16_t features;
-	uint32_t planes_per_lun;
-	int i;
-	int val;
-
-	/* try ONFI for unknow chip or LP */
-	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
-	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
-		chip->read_byte(mtd) != 'F' || chip->read_byte(mtd) != 'I')
-		return 0;
-
-	printk(KERN_INFO "ONFI flash detected\n");
-	chip->cmdfunc(mtd, NAND_CMD_PARAM, 0, -1);
-	for (i = 0; i < 3; i++) {
-		chip->read_buf(mtd, (uint8_t *)p, sizeof(*p));
-		if (onfi_crc16(ONFI_CRC_BASE, (uint8_t *)p, 254) ==
-				le16_to_cpu(p->crc)) {
-			printk(KERN_INFO "ONFI param page %d valid\n", i);
-			break;
-		}
-	}
-
-	if (i == 3)
-		return 0;
-
-	/* check version */
-	val = le16_to_cpu(p->revision);
-	if (val & (1 << 5))
-		chip->onfi_version = 23;
-	else if (val & (1 << 4))
-		chip->onfi_version = 22;
-	else if (val & (1 << 3))
-		chip->onfi_version = 21;
-	else if (val & (1 << 2))
-		chip->onfi_version = 20;
-	else if (val & (1 << 1))
-		chip->onfi_version = 10;
-	else
-		chip->onfi_version = 0;
-
-	if (!chip->onfi_version) {
-		printk(KERN_INFO "%s: unsupported ONFI version: %d\n",
-								__func__, val);
-		return 0;
-	}
-
-	sanitize_string(p->manufacturer, sizeof(p->manufacturer));
-	sanitize_string(p->model, sizeof(p->model));
-	if (!mtd->name)
-		mtd->name = p->model;
-
-	mtd->writesize = le32_to_cpu(p->byte_per_page);
-	mtd->oobsize = le16_to_cpu(p->spare_bytes_per_page);
-	chip->luns_per_chip = p->lun_count;
-
-	/* 'interleaved_bits' should really be called 'plane_address_bits' */
-	planes_per_lun = 1 << p->interleaved_bits;
-	chip->planes_per_chip = chip->luns_per_chip * planes_per_lun;
-
-	mtd->erasesize = mtd->writesize * le32_to_cpu(p->pages_per_block);
-	chip->chipsize = (uint64_t)mtd->erasesize *
-		le32_to_cpu(p->blocks_per_lun) *
-		chip->luns_per_chip;
-
-	/* Build up chip options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= (NAND_NO_AUTOINCR | NAND_NO_READRDY);
-
-	features = le16_to_cpu(p->features);
-
-	if (features & (0x1 << 0))
-		chip->options |=  NAND_BUSWIDTH_16;
-	if (features & (0x1 << 1))
-		chip->options |= NAND_MULTILUN;
-	if (features & (0x1 << 3))
-		chip->options |= NAND_MULTIPLANE_PROG_ERASE;
-	if (features & (0x1 << 6))
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	features = le16_to_cpu(p->opt_cmd);
-	if (features & (0x1 << 1))
-		chip->options |= NAND_CACHERD;
-	if (features & (0x1 << 0))
-		chip->options |= NAND_CACHEPRG;
-
-	/* Mimic 'cellinfo' */
-	chip->cellinfo = chip->luns_per_chip;
-	chip->cellinfo |= ((p->bits_per_cell - 1) & 0x3) << 2;
-
-	return 1;
-}
-
-/*
  * Get the flash and manufacturer id and lookup if the type is supported
  */
 static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
@@ -2841,9 +2706,8 @@
 						  int busw, int *maf_id)
 {
 	struct nand_flash_dev *type = NULL;
-	int dev_id, maf_idx, i;
-	u8 id_data[8];
-	int ret;
+	int i, dev_id, maf_idx;
+	int tmp_id, tmp_manf;
 
 	/* Select the device */
 	chip->select_chip(mtd, 0);
@@ -2869,66 +2733,89 @@
 
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
 
-	for (i = 0; i < 2; i++)
-		id_data[i] = chip->read_byte(mtd);
+	/* Read manufacturer and device IDs */
+
+	tmp_manf = chip->read_byte(mtd);
+	tmp_id = chip->read_byte(mtd);
 
-	if (id_data[0] != *maf_id || id_data[1] != dev_id) {
-		pr_info("%s: second ID read did not match "
-			"%02x,%02x against %02x,%02x\n", __func__,
-			*maf_id, dev_id, id_data[0], id_data[1]);
+	if (tmp_manf != *maf_id || tmp_id != dev_id) {
+		printk(KERN_INFO "%s: second ID read did not match "
+		       "%02x,%02x against %02x,%02x\n", __func__,
+		       *maf_id, dev_id, tmp_manf, tmp_id);
 		return ERR_PTR(-ENODEV);
 	}
 
 	/* Lookup the flash id */
-	for (type = nand_flash_ids; type->name != NULL; type++)
-		if (dev_id == type->id)
+	for (i = 0; nand_flash_ids[i].name != NULL; i++) {
+		if (dev_id == nand_flash_ids[i].id) {
+			type =  &nand_flash_ids[i];
 			break;
-
-	chip->onfi_version = 0;
-	if (!type->name || !type->pagesize) {
-		/* Check is chip is ONFI compliant */
-		ret = nand_flash_detect_onfi(mtd, chip, busw);
-		if (ret)
-			goto ident_done;
+		}
 	}
 
-	if (!type->name)
+	if (!type)
 		return ERR_PTR(-ENODEV);
 
 	if (!mtd->name)
 		mtd->name = type->name;
 
-	/* Read entire ID string */
-	chip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);
-	for (i = 0; i < 8; i++)
-		id_data[i] = chip->read_byte(mtd);
+	chip->chipsize = (uint64_t)type->chipsize << 20;
 
-	/* Decode ID string */
-	if (nand_decode_id(mtd, chip, type, id_data, 8) != 0) {
-		printk(KERN_INFO "Failed to decode NAND READID "
-		       "[%02x %02x %02x %02x]\n",
-		       id_data[0], id_data[1], id_data[2], id_data[3]);
-		return ERR_PTR(-EINVAL);
+	/* Newer devices have all the information in additional id bytes */
+	if (!type->pagesize) {
+		int extid;
+		/* The 3rd id byte holds MLC / multichip data */
+		chip->cellinfo = chip->read_byte(mtd);
+		/* The 4th id byte is the important one */
+		extid = chip->read_byte(mtd);
+		/* Calc pagesize */
+		mtd->writesize = 1024 << (extid & 0x3);
+		extid >>= 2;
+		/* Calc oobsize */
+		mtd->oobsize = (8 << (extid & 0x01)) * (mtd->writesize >> 9);
+		extid >>= 2;
+		/* Calc blocksize. Blocksize is multiples of 64KiB */
+		mtd->erasesize = (64 * 1024) << (extid & 0x03);
+		extid >>= 2;
+		/* Get buswidth information */
+		busw = (extid & 0x01) ? NAND_BUSWIDTH_16 : 0;
+
+		/* Micron device: check for 4-bit on-die ECC */
+		if (*maf_id == NAND_MFR_MICRON) {
+			u8 id4, id5;
+			id4 = chip->read_byte(mtd);
+			id5 = chip->read_byte(mtd);
+
+			/* Do we have a 5-byte ID ? */
+			if (!(id4 == *maf_id && id5 == dev_id))
+				/* ECC level in id4[1:0] */
+				if ((id4 & 0x3) == 0x2)
+					chip->ecc.mode = NAND_ECC_4BITONDIE;
+		}
+	} else {
+		/*
+		 * Old devices have chip data hardcoded in the device id table
+		 */
+		mtd->erasesize = type->erasesize;
+		mtd->writesize = type->pagesize;
+		mtd->oobsize = mtd->writesize / 32;
+		busw = type->options & NAND_BUSWIDTH_16;
 	}
 
- ident_done:
-
 	/* Try to identify manufacturer */
 	for (maf_idx = 0; nand_manuf_ids[maf_idx].id != 0x0; maf_idx++) {
 		if (nand_manuf_ids[maf_idx].id == *maf_id)
 			break;
 	}
 
-	printk(KERN_INFO "NAND device: Manufacturer ID:"
-	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
-	       nand_manuf_ids[maf_idx].name,
-	       chip->onfi_version ? chip->onfi_params.model : type->name);
-
 	/*
 	 * Check, if buswidth is correct. Hardware drivers should set
 	 * chip correct !
 	 */
 	if (busw != (chip->options & NAND_BUSWIDTH_16)) {
+		printk(KERN_INFO "NAND device: Manufacturer ID:"
+		       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id,
+		       dev_id, nand_manuf_ids[maf_idx].name, mtd->name);
 		printk(KERN_WARNING "NAND bus width %d instead %d bit\n",
 		       (chip->options & NAND_BUSWIDTH_16) ? 16 : 8,
 		       busw ? 16 : 8);
@@ -2947,10 +2834,24 @@
 	else
 		chip->chip_shift = ffs((unsigned)(chip->chipsize >> 32)) + 32 - 1;
 
+	/* Set the bad block position */
+	chip->badblockpos = mtd->writesize > 512 ?
+		NAND_LARGE_BADBLOCK_POS : NAND_SMALL_BADBLOCK_POS;
+
+	/* Get chip options, preserve non chip based options */
+	chip->options &= ~NAND_CHIPOPTIONS_MSK;
+	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
+
 	/*
-	 * Detmine manufactuer's bad-block marker scheme
+	 * Set chip as a default. Board drivers can override it, if necessary
+	 */
+	chip->options |= NAND_NO_AUTOINCR;
+
+	/* Check if chip is a not a samsung device. Do not clear the
+	 * options for chips which are not having an extended id.
 	 */
-	nand_derive_bbm(mtd, chip, id_data);
+	if (*maf_id != NAND_MFR_SAMSUNG && !type->pagesize)
+		chip->options &= ~NAND_SAMSUNG_LP_OPTIONS;
 
 	/* Check for AND chips with 4 page planes */
 	if (chip->options & NAND_4PAGE_ARRAY)
@@ -2962,6 +2863,10 @@
 	if (mtd->writesize > 512 && chip->cmdfunc == nand_command)
 		chip->cmdfunc = nand_command_lp;
 
+	printk(KERN_INFO "NAND device: Manufacturer ID:"
+	       " 0x%02x, Chip ID: 0x%02x (%s %s)\n", *maf_id, dev_id,
+	       nand_manuf_ids[maf_idx].name, type->name);
+
 	return type;
 }
 
@@ -3328,8 +3233,7 @@
 static int __init nand_base_init(void)
 {
 #ifdef CONFIG_DEBUG_FS
-	file_erasebb = debugfs_create_u8("nanderasebb", 0644, NULL,
-					 &nand_erasebb);
+	file_erasebb = debugfs_create_u8("nanderasebb", 0644, NULL, &erasebb);
 #endif
 
 	led_trigger_register_simple("nand-disk", &nand_led_trigger);
--- a/drivers/mtd/nand/nand_ids.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/nand_ids.c	2009-12-03 04:51:21.000000000 +0100
@@ -73,24 +73,17 @@
 #define LP_OPTIONS (NAND_SAMSUNG_LP_OPTIONS | NAND_NO_READRDY | NAND_NO_AUTOINCR)
 #define LP_OPTIONS16 (LP_OPTIONS | NAND_BUSWIDTH_16)
 
-	/* 512 Megabit */
+	/*512 Megabit */
 	{"NAND 64MiB 1,8V 8-bit",	0xA2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 1,8V 8-bit",	0xA0, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 3,3V 8-bit",	0xF2, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xD0, 0,  64, 0, LP_OPTIONS},
-	{"NAND 64MiB 3,3V 8-bit",	0xF0, 0,  64, 0, LP_OPTIONS},
 	{"NAND 64MiB 1,8V 16-bit",	0xB2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 1,8V 16-bit",	0xB0, 0,  64, 0, LP_OPTIONS16},
 	{"NAND 64MiB 3,3V 16-bit",	0xC2, 0,  64, 0, LP_OPTIONS16},
-	{"NAND 64MiB 3,3V 16-bit",	0xC0, 0,  64, 0, LP_OPTIONS16},
 
 	/* 1 Gigabit */
 	{"NAND 128MiB 1,8V 8-bit",	0xA1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 3,3V 8-bit",	0xF1, 0, 128, 0, LP_OPTIONS},
-	{"NAND 128MiB 3,3V 8-bit",	0xD1, 0, 128, 0, LP_OPTIONS},
 	{"NAND 128MiB 1,8V 16-bit",	0xB1, 0, 128, 0, LP_OPTIONS16},
 	{"NAND 128MiB 3,3V 16-bit",	0xC1, 0, 128, 0, LP_OPTIONS16},
-	{"NAND 128MiB 1,8V 16-bit",     0xAD, 0, 128, 0, LP_OPTIONS16},
 
 	/* 2 Gigabit */
 	{"NAND 256MiB 1,8V 8-bit",	0xAA, 0, 256, 0, LP_OPTIONS},
@@ -116,36 +109,6 @@
 	{"NAND 2GiB 1,8V 16-bit",	0xB5, 0, 2048, 0, LP_OPTIONS16},
 	{"NAND 2GiB 3,3V 16-bit",	0xC5, 0, 2048, 0, LP_OPTIONS16},
 
-	/* 32 Gigabit */
-	{"NAND 4GiB 1,8V 8-bit",	0xA7, 0, 4096, 0, LP_OPTIONS},
-	{"NAND 4GiB 3,3V 8-bit",	0xD7, 0, 4096, 0, LP_OPTIONS},
-	{"NAND 4GiB 1,8V 16-bit",	0xB7, 0, 4096, 0, LP_OPTIONS16},
-	{"NAND 4GiB 3,3V 16-bit",	0xC7, 0, 4096, 0, LP_OPTIONS16},
-
-	/* 64 Gigabit */
-	{"NAND 8GiB 1,8V 8-bit",	0xAE, 0, 8192, 0, LP_OPTIONS},
-	{"NAND 8GiB 3,3V 8-bit",	0xDE, 0, 8192, 0, LP_OPTIONS},
-	{"NAND 8GiB 1,8V 16-bit",	0xBE, 0, 8192, 0, LP_OPTIONS16},
-	{"NAND 8GiB 3,3V 16-bit",	0xCE, 0, 8192, 0, LP_OPTIONS16},
-
-	/* 128 Gigabit */
-	{"NAND 16GiB 1,8V 8-bit",	0x1A, 0, 16384, 0, LP_OPTIONS},
-	{"NAND 16GiB 3,3V 8-bit",	0x3A, 0, 16384, 0, LP_OPTIONS},
-	{"NAND 16GiB 1,8V 16-bit",	0x2A, 0, 16384, 0, LP_OPTIONS16},
-	{"NAND 16GiB 3,3V 16-bit",	0x4A, 0, 16384, 0, LP_OPTIONS16},
-
-	/* 256 Gigabit */
-	{"NAND 32GiB 1,8V 8-bit",	0x1C, 0, 32768, 0, LP_OPTIONS},
-	{"NAND 32GiB 3,3V 8-bit",	0x3C, 0, 32768, 0, LP_OPTIONS},
-	{"NAND 32GiB 1,8V 16-bit",	0x2C, 0, 32768, 0, LP_OPTIONS16},
-	{"NAND 32GiB 3,3V 16-bit",	0x4C, 0, 32768, 0, LP_OPTIONS16},
-
-	/* 512 Gigabit */
-	{"NAND 64GiB 1,8V 8-bit",	0x1E, 0, 65536, 0, LP_OPTIONS},
-	{"NAND 64GiB 3,3V 8-bit",	0x3E, 0, 65536, 0, LP_OPTIONS},
-	{"NAND 64GiB 1,8V 16-bit",	0x2E, 0, 65536, 0, LP_OPTIONS16},
-	{"NAND 64GiB 3,3V 16-bit",	0x4E, 0, 65536, 0, LP_OPTIONS16},
-
 	/*
 	 * Renesas AND 1 Gigabit. Those chips do not support extended id and
 	 * have a strange page/block layout !  The chosen minimum erasesize is
@@ -177,499 +140,12 @@
 	{NAND_MFR_HYNIX, "Hynix"},
 	{NAND_MFR_MICRON, "Micron"},
 	{NAND_MFR_AMD, "AMD"},
-	{NAND_MFR_MACRONIX, "Macronix"},
 	{0x0, "Unknown"}
 };
 
 EXPORT_SYMBOL(nand_manuf_ids);
 EXPORT_SYMBOL(nand_flash_ids);
 
-/*
- *	Decode READID data
- */
-
-static int nand_decode_id_2(struct mtd_info *mtd,
-			    struct nand_chip *chip,
-			    struct nand_flash_dev *type,
-			    uint8_t *id, int id_len)
-{
-	mtd->writesize = type->pagesize;
-	mtd->oobsize = type->pagesize / 32;
-	chip->chipsize = ((uint64_t)type->chipsize) << 20;
-
-	/* SPANSION/AMD (S30ML-P ORNAND) has non-standard block size */
-	if (id[0] == NAND_MFR_AMD)
-		mtd->erasesize = 512 * 1024;
-	else
-		mtd->erasesize = type->erasesize;
-
-	/* Get chip options from table */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= type->options & NAND_CHIPOPTIONS_MSK;
-	chip->options |= NAND_NO_AUTOINCR;
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	/* Assume some defaults */
-	chip->cellinfo = 0;
-	chip->planes_per_chip = 1;
-	chip->planes_per_chip = 1;
-	chip->luns_per_chip = 1;
-
-	return 0;
-}
-
-static int nand_decode_id_ext(struct mtd_info *mtd,
-			      struct nand_chip *chip,
-			      struct nand_flash_dev *type,
-			      uint8_t *id, int id_len) {
-	uint8_t data;
-
-	if (id_len < 3 || id_len > 5) {
-		pr_err("[MTD][NAND]: %s: invalid ID length [%d]\n",
-		       __func__, id_len);
-		return 1;
-	}
-
-	/* Clear chip options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-
-	/* ID4: Planes/Chip Size */
-	if (id[0] == NAND_MFR_HYNIX && id_len == 5 && id[4] == 0 &&
-	    (id[1] == 0xDA || id[1] == 0xCA)) {
-		/* Non-standard decode: HY27UF082G2A, HY27UF162G2A */
-		chip->planes_per_chip = 2;
-		chip->chipsize = (128 * 1024 * 1024) * chip->planes_per_chip;
-	} else if (id[0] == NAND_MFR_HYNIX && id_len == 5 &&
-		   id[1] == 0xD5 && id[4] == 0x44) {
-		/* Non-standard decode: H27UAG8T2M */
-		chip->planes_per_chip = 2;
-		chip->chipsize = (1024UL * 1024 * 1024) * chip->planes_per_chip;
-	} else if (id_len == 5) {
-		/*   - Planes per chip: ID4[3:2] */
-		data = (id[4] >> 2) & 0x3;
-		chip->planes_per_chip = 1 << data;
-
-		if (id[0] != NAND_MFR_TOSHIBA) {
-			/*   - Plane size: ID4[6:4], multiples of 8MiB */
-			data = (id[4] >> 4) & 0x7;
-			chip->chipsize = (8 * 1024 * 1024) << data;
-			chip->chipsize *= chip->planes_per_chip;
-		} else {
-			/* Toshiba ID4 does not give plane size: get chipsize
-			 * from table */
-			chip->chipsize = (((uint64_t)type->chipsize) << 20);
-		}
-	} else {
-		/* Fall-back to table */
-		chip->planes_per_chip = 1;
-		chip->chipsize = (((uint64_t)type->chipsize) << 20);
-	}
-
-	/* ID3: Page/OOB/Block Size */
-	if (id_len >= 4) {
-		/*   - Page Size: ID3[1:0] */
-		data = id[3] & 0x3;
-		mtd->writesize = 1024 << data; /* multiples of 1k */
-
-		/*   - OOB Size: ID3[2] */
-		data = (id[3] >> 2) & 0x1;
-		mtd->oobsize = 8 << data;		/* per 512 */
-		mtd->oobsize *= mtd->writesize / 512;	/* per page */
-
-		/* TC58NVG3S0F: non-standard OOB size! */
-		if (id[0] == NAND_MFR_TOSHIBA && id[1] == 0xD3 &&
-		    id[2] == 0x90 && id[3] == 0x26 && id[4] == 0x76)
-			mtd->oobsize = 232;
-
-		/*   - Block Size: ID3[5:4] */
-		data = (id[3] >> 4) & 0x3;
-		mtd->erasesize = (64 * 1024) << data; /* multiples of 64k */
-
-		/*   - Bus Width; ID3[6] */
-		if ((id[3] >> 6) & 0x1)
-			chip->options |= NAND_BUSWIDTH_16;
-	} else {
-		/* Fall-back to table */
-		mtd->writesize = type->pagesize;
-		mtd->oobsize = type->pagesize / 32;
-		if (type->options & NAND_BUSWIDTH_16)
-			chip->options |= NAND_BUSWIDTH_16;
-	}
-
-	/* Some default 'chip' options */
-	chip->options |= NAND_NO_AUTOINCR;
-	if (chip->planes_per_chip > 1)
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	if (id[0] == NAND_MFR_SAMSUNG && mtd->writesize > 512)
-		chip->options |= NAND_SAMSUNG_LP_OPTIONS;
-
-	/* ID2: Package/Cell/Features */
-	/*   Note, ID2 invalid, or documented as "don't care" on certain devices
-	 *   (assume some defaults)
-	 */
-	if (id_len == 4 && id[0] == NAND_MFR_HYNIX &&
-	    (id[1] == 0xF1 || id[1] == 0xC1 || id[1] == 0xA1 || id[1] == 0xAD ||
-	     id[1] == 0xDA || id[1] == 0xCA)) {
-		/* HY27{U,S}F{08,16}1G2M;
-		 * HY27UF{08,16}2G2M
-		 */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else if (id_len == 4 && id[0] == NAND_MFR_MICRON &&
-		   (id[1] == 0xDA || id[1] == 0xCA || id[1] == 0xDC ||
-		    id[1] == 0xCC || id[1] == 0xAA || id[1] == 0xBA)) {
-		/* MT29F2G{08,16}AAB;
-		 * MT29F4G{08,16}BAB;
-		 * MT29F2G{08,16}A{A,B}C;
-		 * MT29F4G08BAC
-		 */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else if (id_len == 4 && id[0] == NAND_MFR_SAMSUNG &&
-		   (id[1] == 0xF1 || id[1] == 0xA1)) {
-		/* K9F1G08{U,Q}A */
-		chip->luns_per_chip = 1;
-		chip->cellinfo = 0;
-		chip->options |= (NAND_CACHEPRG |
-				  NAND_CACHERD |
-				  NAND_COPYBACK);
-	} else {
-		/*   - LUNs: ID2[1:0] */
-		data = id[2] & 0x3;
-		chip->luns_per_chip = 0x1 << data;
-
-		/*   - Interleave: ID2[6] */
-		if ((id[2] >> 6) & 0x1)
-			chip->options |= NAND_MULTILUN;
-
-		/*   - Cache Program: ID2[7] */
-		if ((id[2] >> 7) & 0x1)
-			chip->options |= NAND_CACHEPRG;
-
-		/*   - Copy to 'cellinfo' */
-		chip->cellinfo = id[2];
-	}
-
-	return 0;
-}
-
-static int nand_decode_id_6(struct mtd_info *mtd,
-			    struct nand_chip *chip,
-			    struct nand_flash_dev *type,
-			    uint8_t *id, int id_len) {
-	uint8_t data;
-
-	if (id_len != 6) {
-		pr_err("[MTD][NAND]: %s: invalid ID length [%d]\n",
-		       __func__, id_len);
-		return 1;
-	}
-
-	chip->chipsize = (((uint64_t)type->chipsize) << 20);
-
-	/* ID4: Planes */
-	/*   - Number: ID4[3:2] */
-	data = (id[4] >> 2) & 0x3;
-	chip->planes_per_chip = 1 << data;
-
-	/* ID3: Page/OOB/Block Size */
-	/*   - Page Size:  ID3[1:0] */
-	data = id[3] & 0x3;
-	mtd->writesize = 2048 << data; /* multiples of 2k */
-
-	/*   - OOB Size: ID3[6,3:2] */
-	data = ((id[3] >> 4) & 0x4) | ((id[3] >> 2) & 0x3);
-	if (id[0] == NAND_MFR_SAMSUNG) {
-		switch (data) {
-		case 1:
-			mtd->oobsize = 128;
-			break;
-		case 2:
-			mtd->oobsize = 218;
-			break;
-		case 3:
-			mtd->oobsize = 400;
-			break;
-		case 4:
-			mtd->oobsize = 436;
-			break;
-		case 5:
-			mtd->oobsize = 640;
-			break;
-		default:
-			pr_err("[MTD][NAND]: %s: unknown OOB size\n",
-			       __func__);
-			return 1;
-			break;
-		}
-	} else {
-		switch (data) {
-		case 0:
-			mtd->oobsize = 128;
-			break;
-		case 1:
-			mtd->oobsize = 224;
-			break;
-		case 2:
-			mtd->oobsize = 448;
-			break;
-		default:
-			pr_err("[MTD][NAND]: %s: unknown OOB size\n",
-			       __func__);
-			break;
-		}
-	}
-
-	/*   - Block Size: ID3[7,5:4] */
-	data = ((id[3] >> 5) & 0x4) | ((id[3] >> 4) & 0x3);
-	switch (data) {
-	case 0:
-	case 1:
-	case 2:
-		mtd->erasesize = (128 * 1024) << data;
-		break;
-	case 3:
-		if (id[0] == NAND_MFR_SAMSUNG)
-			mtd->erasesize = (1024 * 1024);
-		else
-			mtd->erasesize = (768 * 1024);
-		break;
-	case 4:
-	case 5:
-		mtd->erasesize = (1024 * 1024) << (data - 4);
-		break;
-	default:
-		pr_err("[MTD][NAND]: %s: unknown block size\n",
-		       __func__);
-		return 1;
-		break;
-	}
-
-	/* Some default 'chip' options */
-	chip->options &= ~NAND_CHIPOPTIONS_MSK;
-	chip->options |= NAND_NO_AUTOINCR;
-	if (chip->planes_per_chip > 1)
-		chip->options |= NAND_MULTIPLANE_READ;
-
-	if (mtd->writesize > 512)
-		chip->options |= NAND_NO_READRDY;
-
-	if (id[0] == NAND_MFR_SAMSUNG && mtd->writesize > 512)
-		chip->options |= NAND_SAMSUNG_LP_OPTIONS;
-
-	/* ID2: Package/Cell/Features */
-	/*   - LUNs: ID2[1:0] */
-	data = id[2] & 0x3;
-	chip->luns_per_chip = 0x1 << data;
-
-	/*   - Interleave: ID2[6] */
-	if ((id[2] >> 6) & 0x1)
-		chip->options |= NAND_MULTILUN;
-
-	/*   - Cache Program: ID2[7] */
-	if ((id[2] >> 7) & 0x1)
-		chip->options |= NAND_CACHEPRG;
-
-	/*   - Copy to 'cellinfo' */
-	chip->cellinfo = id[2];
-
-	/* Bus Width, from table */
-	chip->options |= (type->options & NAND_BUSWIDTH_16);
-
-	return 0;
-}
-
-
-/*
- * Heuristics for manufacturer-programmed bad-block marker (BBM) schemes
- */
-void nand_derive_bbm(struct mtd_info *mtd, struct nand_chip *chip, uint8_t *id)
-{
-	int bits_per_cell = ((chip->cellinfo >> 2) & 0x3) + 1;
-
-	/*
-	 * Some special cases first...
-	 */
-
-	/* Hynix HY27US1612{1,2}B: 3rd word for x16 device! */
-	if (id[0] == NAND_MFR_HYNIX && id[1] == 0x56) {
-		chip->bbm = (NAND_BBM_PAGE_0 |
-			     NAND_BBM_PAGE_1 |
-			     NAND_BBM_BYTE_OOB_5);
-		goto set_bbt_options;
-	}
-
-	/* Hynix MLC VLP: last and last-2 pages, byte 0 */
-	if (id[0] == NAND_MFR_HYNIX && bits_per_cell == 2 &&
-	    mtd->writesize == 4096) {
-		chip->bbm = (NAND_BBM_PAGE_LAST |
-			     NAND_BBM_PAGE_LMIN2 |
-			     NAND_BBM_BYTE_OOB_0);
-		goto set_bbt_options;
-	}
-
-	/* Numonyx/ST 2K/4K pages, x8 bus use BOTH byte 0 and 5 (drivers may
-	 * need to disable 'byte 5' depending on ECC layout)
-	 */
-	if (!(chip->options & NAND_BUSWIDTH_16) &&
-	    mtd->writesize >= 2048 && id[0] == NAND_MFR_STMICRO) {
-		chip->bbm =  (NAND_BBM_PAGE_0 |
-			      NAND_BBM_BYTE_OOB_0 |
-			      NAND_BBM_BYTE_OOB_5);
-		goto set_bbt_options;
-	}
-
-	/* Samsung and Hynix MLC NAND: last page, byte 0; and 1st page for 8KiB
-	 * page devices */
-	if ((id[0] == NAND_MFR_SAMSUNG || id[0] == NAND_MFR_HYNIX) &&
-	    bits_per_cell == 2) {
-		chip->bbm = NAND_BBM_PAGE_LAST | NAND_BBM_BYTE_OOB_0;
-		if (mtd->writesize == 8192)
-			chip->bbm |= NAND_BBM_PAGE_0;
-		goto set_bbt_options;
-	}
-
-	/* Micron 2KiB page devices use 1st and 2nd page, byte 0 */
-	if (id[0] == NAND_MFR_MICRON && mtd->writesize == 2048) {
-		chip->bbm = NAND_BBM_PAGE_0 | NAND_BBM_PAGE_1 |
-			NAND_BBM_BYTE_OOB_0;
-		goto set_bbt_options;
-	}
-
-
-	/*
-	 * For the rest...
-	 */
-
-	/* Scan at least the first page */
-	chip->bbm = NAND_BBM_PAGE_0;
-	/* Also 2nd page for SLC Samsung, Hynix, Toshiba (LP), AMD/Spansion */
-	if (bits_per_cell == 1 &&
-	    (id[0] == NAND_MFR_SAMSUNG ||
-	     id[0] == NAND_MFR_HYNIX ||
-	     id[0] == NAND_MFR_AMD ||
-	     (id[0] == NAND_MFR_TOSHIBA && mtd->writesize > 512)))
-		chip->bbm |= NAND_BBM_PAGE_1;
-
-	/* SP x8 devices use 6th byte OOB; everything else uses 1st byte OOB */
-	if (mtd->writesize == 512 && !(chip->options & NAND_BUSWIDTH_16))
-		chip->bbm |= NAND_BBM_BYTE_OOB_5;
-	else
-		chip->bbm |= NAND_BBM_BYTE_OOB_0;
-
- set_bbt_options:
-	/* Set BBT chip->options, for backwards compatibility */
-	if (chip->bbm & NAND_BBM_PAGE_ALL)
-		chip->options |= NAND_BBT_SCANALLPAGES;
-
-	if (chip->bbm & NAND_BBM_PAGE_1)
-		chip->options |= NAND_BBT_SCAN2NDPAGE;
-
-	/* Set the bad block position */
-	if (mtd->writesize > 512 || (chip->options & NAND_BUSWIDTH_16))
-		chip->badblockpos = NAND_LARGE_BADBLOCK_POS;
-	else
-		chip->badblockpos = NAND_SMALL_BADBLOCK_POS;
-
-	return;
-}
-EXPORT_SYMBOL(nand_derive_bbm);
-
-/*
- * Find the length of the 'READID' string.  It is assumed that the length can be
- * determined by looking for repeated sequences, or that the device returns
- * 0x00's after the string has been returned.
- */
-static int nand_get_id_len(uint8_t *id, int max_id_len)
-{
-	int i, len;
-
-	/* Determine signature length by looking for repeats */
-	for (len = 2; len < max_id_len; len++) {
-		for (i = len; i < max_id_len; i++)
-			if (id[i] != id[i % len])
-				break;
-
-		if (i == max_id_len)
-			break;
-	}
-
-	/* No repeats found, look for trailing 0x00s */
-	if (len == max_id_len) {
-		while (len > 2 && id[len - 1] == 0x00)
-			len--;
-	}
-
-	/*
-	 * Some Toshiba devices return additional, undocumented, READID bytes
-	 * (e.g. TC58NVG3S0F).  Cap ID length to 5 bytes.
-	 */
-	if (id[0] == NAND_MFR_TOSHIBA && len > 5)
-		len = 5;
-
-	/*
-	 * Some Samsung devices return 'NAND_MFR_SAMSUNG' as a 6th READID
-	 * byte. (e.g. K9F4G08U0D). Use ID length of 5 bytes.
-	 */
-	if (id[0] == NAND_MFR_SAMSUNG && len == 6 &&
-	    id[5] == NAND_MFR_SAMSUNG && id[6] == NAND_MFR_SAMSUNG)
-		len = 5;
-
-	return len;
-}
-
-/*
- * Determine device properties by decoding the 'READID' string
- */
-int nand_decode_id(struct mtd_info *mtd,
-		   struct nand_chip *chip,
-		   struct nand_flash_dev *type,
-		   uint8_t *id, int max_id_len)
-{
-	int id_len;
-	int ret;
-
-	id_len = nand_get_id_len(id, max_id_len);
-	if (id_len == 0) {
-		pr_err("[MTD][NAND]: %s: failed to read device ID\n",
-		       __func__);
-		return 1;
-	}
-
-	/*
-	 * Decode ID string
-	 */
-	if (id_len == 2 || type->pagesize)
-		ret = nand_decode_id_2(mtd, chip, type, id, id_len);
-	else if (id_len <= 5)
-		ret = nand_decode_id_ext(mtd, chip, type, id, id_len);
-	else if (id_len == 6)
-		ret = nand_decode_id_6(mtd, chip, type, id, id_len);
-	else
-		ret = 1;
-
-	if (ret) {
-		pr_err("[MTD][NAND]: %s: failed to decode NAND "
-		       "device ID\n", __func__);
-		return ret;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(nand_decode_id);
-
-
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Thomas Gleixner <tglx@linutronix.de>");
 MODULE_DESCRIPTION("Nand device & manufacturer IDs");
--- a/drivers/mtd/nand/stm_nand_afm.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/stm_nand_afm.c	2012-11-11 01:39:29.000000000 +0100
@@ -32,7 +32,7 @@
 #include <linux/delay.h>
 
 #include "stm_nand_ecc.h"
-#include "stm_nand_regs.h"
+#include "stm_nandc_regs.h"
 
 #define NAME	"stm-nand-afm"
 
@@ -480,14 +480,21 @@
  * AFM Interrupts
  */
 
+#define AFM_IRQ			(1 << 0)
+#define AFM_IRQ_RBN		(1 << 2)
+#define AFM_IRQ_DATA_DREQ	(1 << 3)
+#define AFM_IRQ_SEQ_DREQ	(1 << 4)
+#define AFM_IRQ_CHECK		(1 << 5)
+#define AFM_IRQ_ECC_FIX		(1 << 6)
+
 static void afm_enable_interrupts(struct stm_nand_afm_controller *afm,
 				  uint32_t irqs)
 {
 	uint32_t reg;
 
-	reg = afm_readreg(NANDHAM_INT_EN);
+	reg = afm_readreg(EMINAND_INTERRUPT_ENABLE);
 	reg |= irqs;
-	afm_writereg(reg, NANDHAM_INT_EN);
+	afm_writereg(reg, EMINAND_INTERRUPT_ENABLE);
 
 }
 
@@ -496,9 +503,9 @@
 {
 	uint32_t reg;
 
-	reg = afm_readreg(NANDHAM_INT_EN);
+	reg = afm_readreg(EMINAND_INTERRUPT_ENABLE);
 	reg &= ~irqs;
-	afm_writereg(reg, NANDHAM_INT_EN);
+	afm_writereg(reg, EMINAND_INTERRUPT_ENABLE);
 }
 
 static irqreturn_t afm_irq_handler(int irq, void *dev)
@@ -507,21 +514,21 @@
 		(struct stm_nand_afm_controller *)dev;
 	unsigned int irq_status;
 
-	irq_status = afm_readreg(NANDHAM_INT_STA);
+	irq_status = afm_readreg(EMINAND_INTERRUPT_STATUS);
 
 	/* RBn */
-	if (irq_status & NAND_INT_RBN) {
-		afm_writereg(NAND_INT_CLR_RBN, NANDHAM_INT_CLR);
+	if (irq_status & 0x4) {
+		afm_writereg(0x04, EMINAND_INTERRUPT_CLEAR);
 		complete(&afm->rbn_completed);
 	}
 
 	/* ECC_fix */
-	if (irq_status & NANDHAM_INT_ECC_FIX_REQ)
-		afm_writereg(NANDHAM_INT_CLR_ECC_FIX_REQ, NANDHAM_INT_CLR);
+	if (irq_status & 0x40)
+		afm_writereg(0x10, EMINAND_INTERRUPT_CLEAR);
 
 	/* Seq_req */
-	if (irq_status & NANDHAM_INT_SEQ_DREQ) {
-		afm_writereg(NANDHAM_INT_CLR_SEQ_DREQ, NANDHAM_INT_CLR);
+	if (irq_status & AFM_IRQ_SEQ_DREQ) {
+		afm_writereg(0x40, EMINAND_INTERRUPT_CLEAR);
 		complete(&afm->seq_completed);
 	}
 
@@ -540,23 +547,23 @@
 	uint32_t reg;
 
 	reg = 0x00;
-	/* Bus width */
 	if ((busw & NAND_BUSWIDTH_16) == 0)
-		reg |= AFM_GEN_CFG_DATA_8_NOT_16;
+		reg |= 0x1 << 16;		/* data_8_not_16      */
 
-	/* Page size, Address cycles */
 	if (page_size > 512) {
-		reg |= AFM_GEN_CFG_LARGE_PAGE;
+		/* large page */
+		reg |= 0x1 << 17;		/* page size	      */
 		if (chip_size > (128 << 20))
-			reg |= AFM_GEN_CFG_EXTRA_ADD_CYCLE;
+			reg |= 0x1 << 18;	/* extra addr cycle   */
 	} else if (chip_size > (32 << 20)) {
-		reg |= AFM_GEN_CFG_EXTRA_ADD_CYCLE;
+		/* small page */
+		reg |= 0x1 << 18;		/* extra addr cycle   */
 
 	}
 
-	dev_dbg(afm->dev, "setting AFM_GEN_CFG = 0x%08x\n", reg);
+	dev_dbg(afm->dev, "setting AFM_GENERIC_CONFIG_REG = 0x%08x\n", reg);
 
-	afm_writereg(reg, NANDHAM_AFM_GEN_CFG);
+	afm_writereg(reg, EMINAND_AFM_GENERIC_CONFIG_REG);
 }
 
 /* AFM configure timing parameters */
@@ -593,8 +600,8 @@
 	n = (tm->WE_to_RBn + emi_t_ns - 1)/emi_t_ns;
 	reg |= (n & 0xff) << 24;
 
-	dev_dbg(afm->dev, "setting CTL_TIMING = 0x%08x\n", reg);
-	afm_writereg(reg, NANDHAM_CTL_TIMING);
+	dev_dbg(afm->dev, "setting CONTROL_TIMING = 0x%08x\n", reg);
+	afm_writereg(reg, EMINAND_CONTROL_TIMING);
 
 	/* WEN_TIMING */
 	n = (tm->wr_on + emi_t_ns - 1)/emi_t_ns;
@@ -604,7 +611,7 @@
 	reg |= (n & 0xff) << 8;
 
 	dev_dbg(afm->dev, "setting WEN_TIMING = 0x%08x\n", reg);
-	afm_writereg(reg, NANDHAM_WEN_TIMING);
+	afm_writereg(reg, EMINAND_WEN_TIMING);
 
 	/* REN_TIMING */
 	n = (tm->rd_on + emi_t_ns - 1)/emi_t_ns;
@@ -614,7 +621,7 @@
 	reg |= (n & 0xff) << 8;
 
 	dev_dbg(afm->dev, "setting REN_TIMING = 0x%08x\n", reg);
-	afm_writereg(reg, NANDHAM_REN_TIMING);
+	afm_writereg(reg, EMINAND_REN_TIMING);
 }
 
 /* Initialise the AFM NAND controller */
@@ -638,8 +645,7 @@
 	afm->dev = &pdev->dev;
 
 	/* Request IO Memory */
-	resource = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"nand_mem");
+	resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!resource) {
 		dev_err(&pdev->dev, "failed to find IOMEM resource\n");
 		err = -ENOENT;
@@ -666,7 +672,7 @@
 
 #ifdef CONFIG_STM_NAND_AFM_CACHED
 	/* Setup cached mapping to the AFM data FIFO */
-	afm->fifo_phys = (afm->map_base + NANDHAM_AFM_DATA_FIFO);
+	afm->fifo_phys = (afm->map_base + EMINAND_AFM_DATA_FIFO);
 #ifndef CONFIG_32BIT
 	/* 29-bit uses 'Area 7' address.  [Should this be done in ioremap?] */
 	afm->fifo_phys &= 0x1fffffff;
@@ -674,7 +680,7 @@
 	afm->fifo_cached = ioremap_cache(afm->fifo_phys, 512);
 	if (!afm->fifo_cached) {
 		dev_err(&pdev->dev, "fifo ioremap failed [0x%08x]\n",
-			afm->map_base + NANDHAM_AFM_DATA_FIFO);
+			afm->map_base + EMINAND_AFM_DATA_FIFO);
 		err = -ENXIO;
 		goto err3;
 	}
@@ -683,17 +689,18 @@
 #endif
 
 	/* Setup IRQ handler */
-	afm->irq = platform_get_irq_byname(pdev, "nand_irq");
-	if (afm->irq < 0) {
+	resource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!resource) {
 		dev_err(&pdev->dev, "failed to find IRQ resource\n");
-		err = afm->irq;
+		err = -ENOENT;
 		goto err4;
 	}
 
-	err = request_irq(afm->irq, afm_irq_handler, IRQF_DISABLED,
-			  dev_name(&pdev->dev), afm);
-	if (err) {
+	afm->irq = resource->start;
+	if (request_irq(afm->irq, afm_irq_handler, IRQF_DISABLED,
+			dev_name(&pdev->dev), afm)) {
 		dev_err(&pdev->dev, "irq request failed\n");
+		err = -EBUSY;
 		goto err4;
 	}
 
@@ -706,24 +713,24 @@
 	afm->current_csn = -1;
 
 	/* Stop AFM Controller, in case it's still running! */
-	afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
-	memset(afm->base + NANDHAM_AFM_SEQ_REG_1, 0, 32);
+	afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
+	memset(afm->base + EMINAND_AFM_SEQUENCE_REG_1, 0, 32);
 
 	/* Reset AFM Controller */
-	afm_writereg((0x1 << 3), NANDHAM_FLEXMODE_CFG);
+	afm_writereg((0x1 << 3), EMINAND_FLEXMODE_CONFIG);
 	udelay(1);
-	afm_writereg(0x00, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00, EMINAND_FLEXMODE_CONFIG);
 
 	/* Disable boot_not_flex */
-	afm_writereg(0x00000000, NANDHAM_BOOTBANK_CFG);
+	afm_writereg(0x00000000, EMINAND_BOOTBANK_CONFIG);
 
 	/* Set Controller to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 
 	/* Enable Interrupts: individual interrupts enabled when needed! */
-	afm_writereg(0x0000007C, NANDHAM_INT_CLR);
-	afm_writereg(NAND_EDGE_CFG_RBN_RISING, NANDHAM_INT_EDGE_CFG);
-	afm_writereg(NAND_INT_ENABLE, NANDHAM_INT_EN);
+	afm_writereg(0x0000007C, EMINAND_INTERRUPT_CLEAR);
+	afm_writereg(0x00000001, EMINAND_INTERRUPT_EDGECONFIG);
+	afm_writereg(AFM_IRQ, EMINAND_INTERRUPT_ENABLE);
 
 	/* Success :-) */
 	return afm;
@@ -934,12 +941,6 @@
 	page = realpage & chip->pagemask;
 
 	while (1) {
-#ifdef CONFIG_STM_NAND_AFM_PBLBOOTBOUNDARY
-		/* Need to check/Update ECC scheme if using PBL boot-boundary */
-		afm_select_eccparams(mtd, page << chip->page_shift);
-		if (ops->mode == MTD_OOB_AUTO)
-			len = chip->ecc.layout->oobavail;
-#endif
 		sndcmd = chip->ecc.read_oob(mtd, chip, page, sndcmd);
 
 		len = min(len, readlen);
@@ -1015,10 +1016,6 @@
 	oob = ops->oobbuf;			/* pointer to oob buf	*/
 
 	while (1) {
-#ifdef CONFIG_STM_NAND_AFM_PBLBOOTBOUNDARY
-		/* Need to check/Update ECC scheme if using PBL boot-boundary */
-		afm_select_eccparams(mtd, page << chip->page_shift);
-#endif
 		/* #bytes in next transfer */
 		bytes = min(mtd->writesize - col, readlen);
 		/* tranfer aligned to page? */
@@ -1122,14 +1119,14 @@
 	uint32_t status;
 
 	/* Switch to Flex Mode */
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/* Read status register */
-	afm_writereg(FLEX_CMD(NAND_CMD_STATUS), NANDHAM_FLEX_CMD);
-	status = afm_readreg(NANDHAM_FLEX_DATA);
+	afm_writereg(FLX_CMD(NAND_CMD_STATUS), EMINAND_FLEX_COMMAND_REG);
+	status = afm_readreg(EMINAND_FLEX_DATA);
 
 	/* Switch back to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 
 	return (status & NAND_STATUS_WP) ? 0 : 1;
 }
@@ -1315,10 +1312,6 @@
 		int cached = writelen > bytes && page != blockmask;
 		uint8_t *wbuf = buf;
 
-#ifdef CONFIG_STM_NAND_AFM_PBLBOOTBOUNDARY
-		/* Need to check/Update ECC scheme if using PBL boot-boundary */
-		afm_select_eccparams(mtd, page << chip->page_shift);
-#endif
 		/* Partial page write ? */
 		/* TODO: change alignment constraints for DMA transfer! */
 		if (unlikely(column || writelen < (mtd->writesize - 1) ||
@@ -1636,7 +1629,7 @@
 #endif
 	/* Mop up any remaining bytes */
 	while (lenleft > 0) {
-		*buf++ = readb(afm->base + NANDHAM_AFM_DATA_FIFO);
+		*buf++ = readb(afm->base + EMINAND_AFM_DATA_FIFO);
 		lenleft--;
 	}
 }
@@ -1646,7 +1639,7 @@
 {
 	struct stm_nand_afm_controller *afm = mtd_to_afm(mtd);
 
-	readsl(afm->base + NANDHAM_AFM_DATA_FIFO, buf, len/4);
+	readsl(afm->base + EMINAND_AFM_DATA_FIFO, buf, len/4);
 }
 #endif
 
@@ -1655,7 +1648,7 @@
 {
 	struct stm_nand_afm_controller *afm = mtd_to_afm(mtd);
 
-	writesl(afm->base + NANDHAM_AFM_DATA_FIFO, buf, len/4);
+	writesl(afm->base + EMINAND_AFM_DATA_FIFO, buf, len/4);
 }
 
 
@@ -1677,7 +1670,7 @@
 
 	/* Initialise Seq interrupts */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/* Select AFM program */
 	if ((mtd->writesize == 512 && chip->chipsize > (32 << 20)) ||
@@ -1691,24 +1684,24 @@
 	prog->extra_reg	= page;
 
 	/* Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Wait for sequence to finish */
 	ret = wait_for_completion_timeout(&afm->seq_completed, 2*HZ);
 	if (!ret) {
 		dev_warn(afm->dev, "sequence timeout, force exit!\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return;
 	}
 
 	/* Get status */
-	reg = afm_readreg(NANDHAM_AFM_SEQ_STA);
+	reg = afm_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
 	afm->status =  NAND_STATUS_READY | ((reg & 0x60) >> 5);
 
 	/* Disable interrupts */
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 }
 
 static int afm_correct_ecc(struct mtd_info *mtd, unsigned char *buf,
@@ -1766,7 +1759,7 @@
 
 		/* Get H/W ECC */
 		chkcode_offs = (eccsteps == 1) ? (3 << 2) : (i << 2);
-		ecc_afm = afm_readreg(NANDHAM_AFM_ECC_REG_0 +
+		ecc_afm = afm_readreg(EMINAND_AFM_ECC_CHECKCODE_REG_0 +
 				      chkcode_offs);
 
 		/* Extract ecc_code and ecc_calc */
@@ -1830,27 +1823,27 @@
 
 	/* Initialise RBn interrupt */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
 
 	if (mtd->writesize == 512) {
 		/* SmallPage: Reset ECC counters */
-		reg = afm_readreg(NANDHAM_FLEXMODE_CFG);
+		reg = afm_readreg(EMINAND_FLEXMODE_CONFIG);
 		reg |= (1 << 6);
-		afm_writereg(reg, NANDHAM_FLEXMODE_CFG);
+		afm_writereg(reg, EMINAND_FLEXMODE_CONFIG);
 	}
 
 	/* Set page address */
-	prog->addr_reg = page << 8;
+	prog->addr_reg = afm->page << 8;
 
 	/* Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Wait for data to become available */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "RBn timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
-		afm_disable_interrupts(afm, NAND_INT_RBN);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
+		afm_disable_interrupts(afm, AFM_IRQ_RBN);
 		return 1;
 	}
 	/* Read page data and OOB (SmallPage: +48 bytes dummy data) */
@@ -1858,7 +1851,7 @@
 	chip->read_buf(mtd, chip->oob_poi, 64);
 
 	/* Disable RBn interrupts */
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	return 0;
 }
@@ -1879,13 +1872,13 @@
 
 	/* Initialise RBn interrupt */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
 
 	if (mtd->writesize == 512) {
 		/* SmallPage: Reset ECC counters and set page address */
-		reg = afm_readreg(NANDHAM_FLEXMODE_CFG);
+		reg = afm_readreg(EMINAND_FLEXMODE_CONFIG);
 		reg |= (1 << 6);
-		afm_writereg(reg, NANDHAM_FLEXMODE_CFG);
+		afm_writereg(reg, EMINAND_FLEXMODE_CONFIG);
 
 		prog->addr_reg	= page << 8;
 	} else {
@@ -1894,14 +1887,14 @@
 	}
 
 	/* Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Wait for data to become available */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "RBn timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
-		afm_disable_interrupts(afm, NAND_INT_RBN);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
+		afm_disable_interrupts(afm, AFM_IRQ_RBN);
 		return 1;
 	}
 
@@ -1909,7 +1902,7 @@
 	chip->read_buf(mtd, chip->oob_poi, 64);
 
 	/* Disable RBn Interrupts */
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	return 0;
 }
@@ -1931,18 +1924,18 @@
 
 	/*    Initialise Seq interrupt */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/*    Reset ECC counters */
-	reg = afm_readreg(NANDHAM_FLEXMODE_CFG);
+	reg = afm_readreg(EMINAND_FLEXMODE_CONFIG);
 	reg |= (1 << 6);
-	afm_writereg(reg, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(reg, EMINAND_FLEXMODE_CONFIG);
 
 	/*    Set page address */
 	prog->addr_reg	= afm->page << 8;
 
 	/*    Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/*    Write page data */
 	chip->write_buf(mtd, buf, mtd->writesize);
@@ -1951,18 +1944,18 @@
 	ret = wait_for_completion_timeout(&afm->seq_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "seq timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return;
 	}
 
 	/*    Disable Seq interrupt */
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/* 2. Write OOB data */
 	/*    Populate OOB with ECC data  */
-	ecc_afm = afm_readreg(NANDHAM_AFM_ECC_REG_3);
+	ecc_afm = afm_readreg(EMINAND_AFM_ECC_CHECKCODE_REG_3);
 	chip->oob_poi[0] = ecc_afm & 0xff; ecc_afm >>= 8;
 	chip->oob_poi[1] = ecc_afm & 0xff; ecc_afm >>= 8;
 	chip->oob_poi[2] = ecc_afm & 0xff;
@@ -1973,18 +1966,18 @@
 
 	/*    Switch to FLEX mode for writing OOB */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/*    Write OOB data */
-	afm_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
-	writesl(afm->base + NANDHAM_FLEX_DATA, chip->oob_poi, 4);
-	afm_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
+	afm_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
+	writesl(afm->base + EMINAND_FLEX_DATA, chip->oob_poi, 4);
+	afm_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
 
 	/*    Issue page program command */
-	afm_writereg(FLEX_CMD(NAND_CMD_PAGEPROG), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_PAGEPROG), EMINAND_FLEX_COMMAND_REG);
 
 	/*    Wait for page program operation to complete */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
@@ -1992,13 +1985,13 @@
 		dev_err(afm->dev, "RBn timeout, force exit\n");
 
 	/*     Get status */
-	afm_writereg(FLEX_CMD(NAND_CMD_STATUS), NANDHAM_FLEX_CMD);
-	afm->status = afm_readreg(NANDHAM_FLEX_DATA);
+	afm_writereg(FLX_CMD(NAND_CMD_STATUS), EMINAND_FLEX_COMMAND_REG);
+	afm->status = afm_readreg(EMINAND_FLEX_DATA);
 
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	/* 3. Switch back to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 }
 
 
@@ -2034,18 +2027,18 @@
 
 	/* Initialise Seq interrupt */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/* Reset ECC counters */
-	reg = afm_readreg(NANDHAM_FLEXMODE_CFG);
+	reg = afm_readreg(EMINAND_FLEXMODE_CONFIG);
 	reg |= (1 << 6);
-	afm_writereg(reg, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(reg, EMINAND_FLEXMODE_CONFIG);
 
 	/* Set page address */
 	prog->addr_reg	= afm->page << 8;
 
 	/* Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Write page and oob data */
 	chip->write_buf(mtd, buf, mtd->writesize);
@@ -2055,18 +2048,18 @@
 	ret = wait_for_completion_timeout(&afm->seq_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "seq timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return;
 	}
 
 	/* Get status */
-	reg = afm_readreg(NANDHAM_AFM_SEQ_STA);
+	reg = afm_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
 	afm->status =  NAND_STATUS_READY | ((reg & 0x60) >> 5);
 
 	/* Disable Seq interrupt */
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 }
 
 /* AFM: Write Raw Page and OOB Data [LargePage] */
@@ -2082,13 +2075,13 @@
 
 	/* Initialise Seq Interrupts */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/* Set page address */
 	prog->addr_reg	= afm->page << 8;
 
 	/* Copy program to controller, and start sequence */
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Write page and OOB data */
 	chip->write_buf(mtd, buf, 2048);
@@ -2098,18 +2091,18 @@
 	ret = wait_for_completion_timeout(&afm->seq_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "seq timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return;
 	}
 
 	/* Get status */
-	reg = afm_readreg(NANDHAM_AFM_SEQ_STA);
+	reg = afm_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
 	afm->status =  NAND_STATUS_READY | ((reg & 0x60) >> 5);
 
 	/* Disable Seq Interrupts */
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 }
 
 /* AFM: Write Raw Page and OOB Data [SmallPage] */
@@ -2125,25 +2118,25 @@
 
 	/* Enable sequence interrupts */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	/* 1. Write page data to chip's page buffer */
 	prog->addr_reg	= afm->page << 8;
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	chip->write_buf(mtd, buf, mtd->writesize);
 
 	ret = wait_for_completion_timeout(&afm->seq_completed, HZ/2);
 	if (!ret) {
 		dev_err(afm->dev, "seq timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return;
 	}
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
-	reg = afm_readreg(NANDHAM_AFM_SEQ_STA);
+	reg = afm_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
 	if ((reg & 0x60) != 0) {
 		dev_err(afm->dev, "error programming page data\n");
 		afm->status = NAND_STATUS_FAIL;
@@ -2152,33 +2145,33 @@
 
 	/* 2. Switch to FLEX mode and write OOB data */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/*    Send OOB pointer operation */
-	afm_writereg(FLEX_CMD(NAND_CMD_READOOB),  NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_READOOB),  EMINAND_FLEX_COMMAND_REG);
 
 	/*    Send SEQIN command */
-	afm_writereg(FLEX_CMD(NAND_CMD_SEQIN), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_SEQIN), EMINAND_FLEX_COMMAND_REG);
 
 	/*    Send page address */
-	reg = afm->page << 8 | FLEX_ADDR_ADD8_VALID |
-		FLEX_ADDR_CSN;
+	reg = afm->page << 8 | FLX_ADDR_REG_ADD8_VALID |
+		FLX_ADDR_REG_CSN_STATUS;
 	if (chip->chipsize > (32 << 20))
-		reg |= FLEX_ADDR_BEATS_4;
+		reg |= FLX_ADDR_REG_BEAT_4;
 	else
-		reg |= FLEX_ADDR_BEATS_3;
-	afm_writereg(reg, NANDHAM_FLEX_ADD);
+		reg |= FLX_ADDR_REG_BEAT_3;
+	afm_writereg(reg, EMINAND_FLEX_ADDRESS_REG);
 
 	/*    Send OOB data */
-	afm_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
-	writesl(afm->base + NANDHAM_FLEX_DATA, chip->oob_poi, 4);
-	afm_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
+	afm_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
+	writesl(afm->base + EMINAND_FLEX_DATA, chip->oob_poi, 4);
+	afm_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
 
 	/*    Send page program command */
-	afm_writereg(FLEX_CMD(NAND_CMD_PAGEPROG),  NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_PAGEPROG),  EMINAND_FLEX_COMMAND_REG);
 
 	/* Wait for page program operation to complete */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
@@ -2186,13 +2179,13 @@
 		dev_err(afm->dev, "RBn timeout!\n");
 
 	/*     Get status */
-	afm_writereg(FLEX_CMD(NAND_CMD_STATUS), NANDHAM_FLEX_CMD);
-	afm->status = afm_readreg(NANDHAM_FLEX_DATA);
+	afm_writereg(FLX_CMD(NAND_CMD_STATUS), EMINAND_FLEX_COMMAND_REG);
+	afm->status = afm_readreg(EMINAND_FLEX_DATA);
 
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	/* 3. Switch back to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 }
 
 /* AFM: Write OOB Data [LargePage] */
@@ -2208,11 +2201,11 @@
 
 	/* Enable sequence interrupts */
 	INIT_COMPLETION(afm->seq_completed);
-	afm_enable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_enable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	prog->addr_reg	= (page << 8) | (2048 >> 8);
 
-	memcpy_toio(afm->base + NANDHAM_AFM_SEQ_REG_1, prog, 32);
+	memcpy_toio(afm->base + EMINAND_AFM_SEQUENCE_REG_1, prog, 32);
 
 	/* Write OOB */
 	chip->write_buf(mtd, chip->oob_poi, 64);
@@ -2221,18 +2214,18 @@
 	ret = wait_for_completion_timeout(&afm->seq_completed, HZ);
 	if (!ret) {
 		dev_err(afm->dev, "seq timeout, force exit\n");
-		afm_writereg(0x00000000, NANDHAM_AFM_SEQ_CFG);
+		afm_writereg(0x00000000, EMINAND_AFM_SEQUENCE_CONFIG_REG);
 		afm->status = NAND_STATUS_FAIL;
-		afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+		afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 		return 1;
 	}
 
 	/* Get status */
-	reg = afm_readreg(NANDHAM_AFM_SEQ_STA);
+	reg = afm_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
 	afm->status =  NAND_STATUS_READY | ((reg & 0x60) >> 5);
 
 	/* Disable sequence interrupts */
-	afm_disable_interrupts(afm, NANDHAM_INT_SEQ_DREQ);
+	afm_disable_interrupts(afm, AFM_IRQ_SEQ_DREQ);
 
 	return afm->status & NAND_STATUS_FAIL ? -EIO : 0;
 }
@@ -2250,39 +2243,39 @@
 
 	/* Initialise interrupts */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
 
 	/* Switch to Flex Mode */
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/* Pointer Operation */
-	afm_writereg(FLEX_CMD(NAND_CMD_READOOB), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_READOOB), EMINAND_FLEX_COMMAND_REG);
 
 	/* Send SEQIN command */
-	afm_writereg(FLEX_CMD(NAND_CMD_SEQIN), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_SEQIN), EMINAND_FLEX_COMMAND_REG);
 
 	/* Send Col/Page Addr */
 	reg = (page << 8 |
-	       FLEX_ADDR_RBN |
-	       FLEX_ADDR_ADD8_VALID |
-	       FLEX_ADDR_CSN);
+	       FLX_ADDR_REG_RBN |
+	       FLX_ADDR_REG_ADD8_VALID |
+	       FLX_ADDR_REG_CSN_STATUS);
 
 	if (chip->chipsize > (32 << 20))
 		/* Need extra address cycle for 'large' devices */
-		reg |= FLEX_ADDR_BEATS_4;
+		reg |= FLX_ADDR_REG_BEAT_4;
 	else
-		reg |= FLEX_ADDR_BEATS_3;
-	afm_writereg(reg, NANDHAM_FLEX_ADD);
+		reg |= FLX_ADDR_REG_BEAT_3;
+	afm_writereg(reg, EMINAND_FLEX_ADDRESS_REG);
 
 	/* Write OOB data */
-	afm_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
-	writesl(afm->base + NANDHAM_FLEX_DATA, chip->oob_poi, 4);
-	afm_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAWRITE_CONFIG);
+	afm_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
+	writesl(afm->base + EMINAND_FLEX_DATA, chip->oob_poi, 4);
+	afm_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAWRITE_CONFIG);
 
 	/* Issue Page Program command */
-	afm_writereg(FLEX_CMD(NAND_CMD_PAGEPROG), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_PAGEPROG), EMINAND_FLEX_COMMAND_REG);
 
 	/* Wait for page program operation to complete */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
@@ -2290,16 +2283,16 @@
 		dev_err(afm->dev, "RBn timeout\n");
 
 	/* Get status */
-	afm_writereg(FLEX_CMD(NAND_CMD_STATUS), NANDHAM_FLEX_CMD);
-	status = afm_readreg(NANDHAM_FLEX_DATA);
+	afm_writereg(FLX_CMD(NAND_CMD_STATUS), EMINAND_FLEX_COMMAND_REG);
+	status = afm_readreg(EMINAND_FLEX_DATA);
 
 	afm->status = 0xff & status;
 
 	/* Switch back to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 
 	/* Disable RBn interrupts */
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	return status & NAND_STATUS_FAIL ? -EIO : 0;
 }
@@ -2314,13 +2307,13 @@
 
 	/* Enable RBn interrupts */
 	INIT_COMPLETION(afm->rbn_completed);
-	afm_enable_interrupts(afm, NAND_INT_RBN);
+	afm_enable_interrupts(afm, AFM_IRQ_RBN);
 
 	/* Switch to Flex Mode */
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/* Issue NAND reset */
-	afm_writereg(FLEX_CMD(NAND_CMD_RESET), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_RESET), EMINAND_FLEX_COMMAND_REG);
 
 	/* Wait for reset to complete */
 	ret = wait_for_completion_timeout(&afm->rbn_completed, HZ/2);
@@ -2328,16 +2321,19 @@
 		dev_err(afm->dev, "RBn timeout\n");
 
 	/* Read electronic signature */
-	afm_writereg(FLEX_CMD(NAND_CMD_READID), NANDHAM_FLEX_CMD);
+	afm_writereg(FLX_CMD(NAND_CMD_READID), EMINAND_FLEX_COMMAND_REG);
 
-	reg = (0x00 | FLEX_ADDR_BEATS_1 | FLEX_ADDR_RBN | FLEX_ADDR_CSN);
-	afm_writereg(reg, NANDHAM_FLEX_ADD);
-
-	afm_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		     NANDHAM_FLEX_DATAREAD_CONFIG);
-	reg = afm_readreg(NANDHAM_FLEX_DATA);
-	afm_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	reg = (0x00 |
+	       FLX_ADDR_REG_BEAT_1 |
+	       FLX_ADDR_REG_RBN |
+	       FLX_ADDR_REG_CSN_STATUS);
+	afm_writereg(reg, EMINAND_FLEX_ADDRESS_REG);
+
+	afm_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		     EMINAND_FLEX_DATAREAD_CONFIG);
+	reg = afm_readreg(EMINAND_FLEX_DATA);
+	afm_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 	/* Extract manufacturer and device ID */
 	*maf_id = reg & 0xff;
@@ -2348,10 +2344,10 @@
 	*extid = (reg >> 24) & 0xff;
 
 	/* Switch back to AFM Mode */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 
 	/* Disable RBn interrupts */
-	afm_disable_interrupts(afm, NAND_INT_RBN);
+	afm_disable_interrupts(afm, AFM_IRQ_RBN);
 
 	return 0;
 }
@@ -2467,7 +2463,7 @@
 
 		/* Set CSn on AFM controller */
 		afm->current_csn = data->csn;
-		afm_writereg(0x1 << data->csn, NANDHAM_FLEX_MUXCTRL);
+		afm_writereg(0x1 << data->csn, EMINAND_MUXCONTROL_REG);
 
 		/* Set up timing parameters */
 		afm_set_timings(afm, data->timing_data);
@@ -2512,16 +2508,16 @@
 	uint32_t reg;
 
 	/* Switch to Flex Mode */
-	afm_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
-	/* Write STATUS command (do not set FLEX_CMD_RBN!) */
-	reg = (NAND_CMD_STATUS | FLEX_CMD_BEATS_1 | FLEX_CMD_CSN);
-	afm_writereg(reg, NANDHAM_FLEX_CMD);
+	/* Write STATUS command (do not set FLX_CMD_REG_RBN!) */
+	reg = (NAND_CMD_STATUS | FLX_CMD_REG_BEAT_1 | FLX_CMD_REG_CSN_STATUS);
+	afm_writereg(reg, EMINAND_FLEX_COMMAND_REG);
 
-	reg = afm_readreg(NANDHAM_FLEX_DATA);
+	reg = afm_readreg(EMINAND_FLEX_DATA);
 
 	/* Switch back to AFM */
-	afm_writereg(0x00000002, NANDHAM_FLEXMODE_CFG);
+	afm_writereg(0x00000002, EMINAND_FLEXMODE_CONFIG);
 
 	return reg & 0xff;
 }
@@ -2853,11 +2849,6 @@
 }
 
 #ifdef CONFIG_STM_NAND_AFM_PBLBOOTBOUNDARY
-
-#define PBL_BOOT_BOUNDARY_POINTER	0x0034
-#define PBL_MARKER1			0x09b1b007
-#define PBL_MARKER2			(~(PBL_MARKER1))
-
 /* The NAND_BLOCK_ZERO_REMAP_REG is not implemented on current versions of the
  * NAND controller.  We must therefore scan for the logical block 0 pattern.
  */
@@ -2873,159 +2864,56 @@
 	return 0;
 }
 
-static int find_block_zero(struct mtd_info *mtd)
+static int pbl_boot_boundary(struct mtd_info *mtd, uint32_t *_boundary)
 {
 	struct stm_nand_afm_controller *afm = mtd_to_afm(mtd);
 	struct nand_chip *chip = mtd->priv;
 	struct stm_nand_afm_device *data = chip->priv;
 	uint8_t *buf = chip->buffers->databuf;
-
-	int block, block_end;
-	uint32_t offs;
-	uint32_t page;
+	int block;
+	int block_zero_phys = -1;
 	int pages_per_block;
+	uint32_t boundary_log = 0;
+	uint32_t boundary_phys;
 
 	/* Select boot-mode ECC */
 	afm_select_eccparams(mtd, data->boot_start);
 
+	/* Find logical block zero */
 	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
-
-	block_end = min(512UL, (data->boot_end >> chip->phys_erase_shift));
-
-	for (block = 0; block < block_end; block++) {
-		offs = block << chip->phys_erase_shift;
-
-		/* Skip if block is bad */
-		if (nand_isbad_bbt(mtd, offs, 0))
-			continue;
-
-		page = block * pages_per_block;
-		afm->page = page;
-
-		afm_read_page_boot(mtd, chip, buf, page);
-
-		if (check_block_zero_pattern(buf) == 0)
-			return block;
-	}
-
-	return -1;
-}
-
-static int find_pbl_marker(uint8_t *buf, int len, int *col)
-{
-	uint32_t *s = (uint32_t *)buf;
-	int i;
-
-	/* The PBL offset must also be present in the buffer for success, '0',
-	 * to be returned. */
-	for (i = 0; i < (len / 4) - 2; i++) {
-		if ((s[i] == PBL_MARKER1) && (s[i + 1] == PBL_MARKER2)) {
-			*col = i * 4;
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-/* Find the offset of the PBL.  Note, the PBL is not always located at the start
- * of block zero, so we must search for the PBL Markers and PBL offset. */
-static int find_pbl_offset(struct mtd_info *mtd, int block_zero,
-			   uint32_t *offset)
-{
-	struct stm_nand_afm_controller *afm = mtd_to_afm(mtd);
-	struct nand_chip *chip = mtd->priv;
-	struct stm_nand_afm_device *data = chip->priv;
-
-	int buf_len;
-	uint8_t *buf;
-
-	int pages_per_block;
-	uint32_t delta;
-	int found = 0;
-	int page;
-	int page_end;
-	int col;
-	int marker_size = 2 * sizeof(uint32_t);
-
-	pages_per_block = 1 << (chip->phys_erase_shift - chip->page_shift);
-	page_end = data->boot_end >> chip->page_shift;
-
-	/* Use extended buffer to handle the case where the PBL Markers and the
-	 * Offset straddle a page boundary. */
-	buf_len = mtd->writesize + marker_size;
-	buf = kmalloc(buf_len, GFP_KERNEL);
-	if (!buf) {
-		dev_err(afm->dev, "failed to allocate PBL search buffer\n");
-		return 1;
-	}
-
-	/* Initialise start of buffer - see memcpy() below... */
-	memset(buf, 0x00, marker_size);
-
-	/* Start at block zero */
-	for (page = block_zero * pages_per_block;
-	     page < page_end; page++) {
-
-		afm_read_page_boot(mtd, chip, buf + marker_size, page);
-		if (find_pbl_marker(buf, buf_len, &col) == 0) {
-			found = 1;
-			delta = *((uint32_t *)(buf + col + marker_size));
-			*offset =  (page << chip->page_shift) + col - delta;
-			break;
+	afm->col = 0;
+	afm->page = 0;
+	for (block = 0; block < 512; block++) {
+		if (nand_isbad_bbt(mtd, block << chip->phys_erase_shift, 0)
+		    == 0) {
+			afm_read_page_boot(mtd, chip, buf, afm->page);
+
+			if (check_block_zero_pattern(buf) == 0) {
+				block_zero_phys = block;
+				boundary_log = *((uint32_t *)(buf + 0x0034));
+				break;
+			}
 		}
-
-		/* Copy end of buffer to start, just in case the markers and
-		 * offset straddle a page boundary. */
-		memcpy(buf, buf + (buf_len - marker_size), marker_size);
+		afm->page += pages_per_block;
 	}
 
-	kfree(buf);
-
-	/* Did we find the PBL? */
-	return found ? 0 : 1;
-}
-
-static int pbl_boot_boundary(struct mtd_info *mtd, uint32_t *boundary)
-{
-	struct stm_nand_afm_controller *afm = mtd_to_afm(mtd);
-	struct nand_chip *chip = mtd->priv;
-	uint8_t *buf = chip->buffers->databuf;
-
-	int block_zero;
-	uint32_t pbl_offs = 0x00000000;
-	int pbl_page;
-
-	/* Find logical block zero */
-	block_zero = find_block_zero(mtd);
-	if (block_zero < 0) {
-		dev_err(afm->dev, "failed to find logical block zero\n");
-		return 1;
-	}
-
-	dev_dbg(afm->dev, "block zero: 0x%08x\n",
-		 block_zero << chip->phys_erase_shift);
-
-	/* Find PBL offset */
-	if (find_pbl_offset(mtd, block_zero, &pbl_offs) != 0) {
-		dev_err(afm->dev, "failed to find PBL marker\n");
+	/* Return if we didn't find logical block zero */
+	if (block_zero_phys == -1)
 		return 1;
-	}
-
-	dev_dbg(afm->dev, "PBL offset: 0x%08x\n", pbl_offs);
 
-	if (pbl_offs & (mtd->writesize - 1)) {
-		dev_err(afm->dev, "PBL offset is not page-aligned\n");
-		return 1;
+	/* For bootmode_boundary, map logical offset to physical offset */
+	boundary_phys = block_zero_phys << chip->phys_erase_shift;
+	while (boundary_log >= mtd->erasesize) {
+		boundary_phys += mtd->erasesize;
+		if (!afm_block_isbad(mtd, boundary_phys))
+			boundary_log -= mtd->erasesize;
 	}
+	boundary_phys += boundary_log;		/* Add residual offset */
 
-	/* Extract boot-boundary from PBL image */
-	pbl_page = pbl_offs >> chip->page_shift;
-	afm_read_page_boot(mtd, chip, buf, pbl_page);
-	*boundary = *((uint32_t *)(buf + PBL_BOOT_BOUNDARY_POINTER));
-	*boundary += block_zero << chip->phys_erase_shift;	/* physical */
+	dev_info(afm->dev, "boot-mode boundary = 0x%08x (physical)\n",
+		 boundary_phys);
 
-	dev_info(afm->dev, "PBL boot-boundary: 0x%08x\n", *boundary);
+	*_boundary = boundary_phys;
 
 	return 0;
 }
@@ -3082,6 +2970,14 @@
 		goto err2;
 	}
 
+#ifdef CONFIG_STM_NAND_AFM_BOOTMODESUPPORT
+	/* Set name of boot partition */
+	boot_part_name = nbootpart ? nbootpart :
+		CONFIG_STM_NAND_AFM_BOOTPARTITION;
+	dev_info(afm->dev, "using boot partition name [%s] (from %s)\n",
+		 boot_part_name, nbootpart ? "command line" : "kernel config");
+#endif
+
 #ifdef CONFIG_MTD_PARTITIONS
 	/* Try probing for MTD partitions */
 	data->nr_parts = parse_mtd_partitions(&data->mtd,
@@ -3102,13 +2998,12 @@
 			goto err3;
 
 #ifdef CONFIG_STM_NAND_AFM_BOOTMODESUPPORT
-		/* Set name of boot partition */
-		boot_part_name = nbootpart ? nbootpart :
-			CONFIG_STM_NAND_AFM_BOOTPARTITION;
-
 		/* Update boot-mode slave partition */
 		slave = get_mtd_partition_slave(&data->mtd, boot_part_name);
 		if (slave) {
+			dev_info(afm->dev, "found boot-mode partition "
+				 "updating ECC paramters\n");
+
 			part = PART(slave);
 			data->boot_start = part->offset;
 			data->boot_end = part->offset + slave->size;
@@ -3117,15 +3012,19 @@
 			/* Update 'boot_end' with value in PBL image */
 			if (pbl_boot_boundary(&data->mtd,
 					      &boundary) != 0) {
-				dev_err(afm->dev, "failed to get boot-mode "
-					"boundary from PBL\n");
+				dev_info(afm->dev, "failed to get boot-mode "
+					 "boundary from PBL\n");
 			} else {
 				if (boundary < data->boot_start ||
 				    boundary > data->boot_end) {
-					dev_err(afm->dev, "PBL boot-mode "
-						"boundary lies outside "
-						"boot partition\n");
+					dev_info(afm->dev,
+						 "PBL boot-mode "
+						 "boundary lies outside "
+						 "boot partition\n");
 				} else {
+					dev_info(afm->dev,
+						 "Updating boot-mode "
+						 "ECC boundary from PBL");
 					data->boot_end = boundary;
 				}
 			}
--- a/drivers/mtd/nand/stm_nand_bch.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/stm_nand_bch.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,2603 +0,0 @@
-/*
- *  ------------------------------------------------------------------------
- *  stm_nand_bch.c Support for STMicroelectronics NANDi BCH Controller
- *
- *  See Documentation/mtd/stm-nand-bch-notes.txt for additional information.
- *  ------------------------------------------------------------------------
- *
- *  Copyright (c) 2011 STMicroelectronics Limited
- *  Author: Angus Clark <Angus.Clark@st.com>
- *
- *  ------------------------------------------------------------------------
- *  May be copied or modified under the terms of the GNU General Public
- *  License Version 2.0 only.  See linux/COPYING for more information.
- *  ------------------------------------------------------------------------
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/device.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/stm/platform.h>
-#include <linux/stm/nand.h>
-#include <linux/stm/emi.h>
-#include <linux/utsrelease.h>
-
-#include "stm_nand_regs.h"
-
-#define NAME	"stm-nand-bch"
-
-
-/* NANDi BCH Controller properties */
-#define NANDI_BCH_SECTOR_SIZE			1024
-#define NANDI_BCH_DMA_ALIGNMENT			64
-#define NANDI_BCH_MAX_BUF_LIST			8
-#define NANDI_BCH_BUF_LIST_SIZE			(4 * NANDI_BCH_MAX_BUF_LIST)
-
-/* BCH ECC sizes */
-static int bch_ecc_sizes[] = {
-	[BCH_18BIT_ECC] = 32,
-	[BCH_30BIT_ECC] = 54,
-	[BCH_NO_ECC] = 0,
-};
-
-/*
- * Inband Bad Block Table (IBBT)
- */
-#define NAND_IBBT_NBLOCKS	4
-#define NAND_IBBT_SIGLEN	4
-#define NAND_IBBT_PRIMARY	0
-#define NAND_IBBT_MIRROR	1
-#define NAND_IBBT_SCHEMA	0x10
-#define NAND_IBBT_BCH_SCHEMA	0x10
-
-static uint8_t ibbt_sigs[2][NAND_IBBT_SIGLEN] = {
-	{'B', 'b', 't', '0'},
-	{'1', 't', 'b', 'B'},
-};
-
-static char *bbt_strs[] = {
-	"primary",
-	"mirror",
-};
-
-/* IBBT header */
-struct nand_ibbt_header {
-	uint8_t	signature[4];		/* "Bbt0" or "1tbB" signature */
-	uint8_t version;		/* BBT version ("age") */
-	uint8_t reserved[3];		/* padding */
-	uint8_t schema[4];		/* "base" schema (x4) */
-} __attribute__((__packed__));
-
-/* Extend IBBT header with some stm-nand-bch niceties */
-struct nand_ibbt_bch_header {
-	struct nand_ibbt_header base;
-	uint8_t schema[4];		/* "private" schema (x4) */
-	uint8_t ecc_size[4];		/* ECC bytes (0, 32, 54) (x4) */
-	char	author[64];		/* Arbitrary string for S/W to use */
-}; __attribute__((__packed__))
-
-
-/* Bad Block Table (BBT) */
-struct nandi_bbt_info {
-	uint32_t	bbt_size;		/* Size of bad-block table */
-	uint32_t	bbt_vers[2];		/* Version (Primary/Mirror) */
-	uint32_t	bbt_block[2];		/* Block No. (Primary/Mirror) */
-	uint8_t		*bbt;			/* Table data */
-};
-
-
-/* Collection of MTD/NAND device information */
-struct nandi_info {
-	struct mtd_info		mtd;		/* MTD info */
-	struct nand_chip	chip;		/* NAND chip info */
-
-	struct nand_ecclayout	ecclayout;	/* MTD ECC layout */
-	struct nandi_bbt_info	bbt_info;	/* Bad Block Table */
-	int			nr_parts;	/* Number of MTD partitions */
-	struct	mtd_partition 	*parts;		/* MTD partitions */
-};
-
-/* NANDi Controller (Hamming/BCH) */
-struct nandi_controller {
-	void __iomem		*base;		/* Controller base*/
-	void __iomem		*dma;		/* DMA control base */
-
-						/* IRQ-triggered Completions: */
-	struct completion	seq_completed;	/*   SEQ Over */
-	struct completion	rbn_completed;	/*   RBn */
-
-	struct device		*dev;
-
-	int			bch_ecc_mode;	/* ECC mode */
-
-	uint32_t		page_shift;	/* Some working variables */
-	uint32_t		block_shift;
-	uint32_t		blocks_per_device;
-	uint32_t		sectors_per_page;
-
-	uint8_t			*buf;		/* Some buffers to use */
-	uint8_t			*page_buf;
-	uint8_t			*oob_buf;
-	uint32_t		*buf_list;
-
-	int			cached_page;	/* page number of page in
-						 *  'page_buf' */
-
-	struct nandi_info	info;		/* NAND device info */
-};
-
-/* BCH 'program' structure */
-struct bch_prog {
-	u32	multi_cs_addr[3];
-	u32	multi_cs_config;
-	u8	seq[16];
-	u32	addr;
-	u32	extra;
-	u8	cmd[4];
-	u32	reserved1;
-	u32	gen_cfg;
-	u32	delay;
-	u32	reserved2;
-	u32	seq_cfg;
-} __attribute__((__packed__, aligned(32)));
-
-/* BCH template programs (modified on-the-fly) */
-static struct bch_prog bch_prog_read_page = {
-	.cmd = {
-		NAND_CMD_READ0,
-		NAND_CMD_READSTART,
-	},
-	.seq = {
-		BCH_ECC_SCORE(0),
-		BCH_CMD_ADDR,
-		BCH_CL_CMD_1,
-		BCH_DATA_2_SECTOR,
-		BCH_STOP,
-	},
-	.gen_cfg = (GEN_CFG_DATA_8_NOT_16 |
-		    GEN_CFG_EXTRA_ADD_CYCLE |
-		    GEN_CFG_LAST_SEQ_NODE),
-	.seq_cfg = SEQ_CFG_GO_STOP,
-};
-
-static struct bch_prog bch_prog_write_page = {
-	.cmd = {
-		NAND_CMD_SEQIN,
-		NAND_CMD_PAGEPROG,
-		NAND_CMD_STATUS,
-	},
-	.seq = {
-		BCH_CMD_ADDR,
-		BCH_DATA_4_SECTOR,
-		BCH_CL_CMD_1,
-		BCH_CL_CMD_2,
-		BCH_OP_ERR,
-		BCH_STOP,
-	},
-	.gen_cfg = (GEN_CFG_DATA_8_NOT_16 |
-		    GEN_CFG_EXTRA_ADD_CYCLE |
-		    GEN_CFG_LAST_SEQ_NODE),
-	.seq_cfg = (SEQ_CFG_GO_STOP |
-		    SEQ_CFG_DATA_WRITE),
-};
-
-static struct bch_prog bch_prog_erase_block = {
-	.seq = {
-		BCH_CL_CMD_1,
-		BCH_AL_EX_0,
-		BCH_AL_EX_1,
-		BCH_AL_EX_2,
-		BCH_CL_CMD_2,
-		BCH_CL_CMD_3,
-		BCH_OP_ERR,
-		BCH_STOP,
-	},
-	.cmd = {
-		NAND_CMD_ERASE1,
-		NAND_CMD_ERASE1,
-		NAND_CMD_ERASE2,
-		NAND_CMD_STATUS,
-	},
-	.gen_cfg = (GEN_CFG_DATA_8_NOT_16 |
-		    GEN_CFG_EXTRA_ADD_CYCLE |
-		    GEN_CFG_LAST_SEQ_NODE),
-	.seq_cfg = (SEQ_CFG_GO_STOP |
-		    SEQ_CFG_ERASE),
-};
-
-
-/* Configure BCH read/write/erase programs */
-static void bch_configure_progs(struct nandi_controller *nandi)
-{
-	uint8_t data_opa = ffs(nandi->sectors_per_page) - 1;
-	uint8_t data_instr = BCH_INSTR(BCH_OPC_DATA, data_opa);
-	uint32_t gen_cfg_ecc = nandi->bch_ecc_mode << GEN_CFG_ECC_SHIFT;
-
-	/* Set 'DATA' instruction */
-	bch_prog_read_page.seq[3] = data_instr;
-	bch_prog_write_page.seq[1] = data_instr;
-
-	/* Set ECC mode */
-	bch_prog_read_page.gen_cfg |= gen_cfg_ecc;
-	bch_prog_write_page.gen_cfg |= gen_cfg_ecc;
-	bch_prog_erase_block.gen_cfg |= gen_cfg_ecc;
-}
-
-/*
- * NANDi Interrupts (shared by Hamming and BCH controllers)
- */
-static irqreturn_t nandi_irq_handler(int irq, void *dev)
-{
-	struct nandi_controller *nandi = dev;
-	unsigned int status;
-
-	status = readl(nandi->base + NANDBCH_INT_STA);
-
-	if (status & NANDBCH_INT_SEQNODESOVER) {
-		/* BCH */
-		writel(NANDBCH_INT_CLR_SEQNODESOVER,
-		       nandi->base + NANDBCH_INT_CLR);
-		complete(&nandi->seq_completed);
-	}
-	if (status & NAND_INT_RBN) {
-		/* Hamming */
-		writel(NAND_INT_CLR_RBN, nandi->base + NANDHAM_INT_CLR);
-		complete(&nandi->rbn_completed);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static void nandi_enable_interrupts(struct nandi_controller *nandi,
-				    uint32_t irqs)
-{
-	uint32_t val;
-
-	val = readl(nandi->base + NANDBCH_INT_EN);
-	val |= irqs;
-	writel(val, nandi->base + NANDBCH_INT_EN);
-}
-
-static void nandi_disable_interrupts(struct nandi_controller *nandi,
-				     uint32_t irqs)
-{
-	uint32_t val;
-
-	val = readl(nandi->base + NANDBCH_INT_EN);
-	val &= ~irqs;
-	writel(val, nandi->base + NANDBCH_INT_EN);
-}
-
-/*
- * BCH Operations
- */
-static inline void bch_load_prog_cpu(struct nandi_controller *nandi,
-				     struct bch_prog *prog)
-{
-	memcpy_toio(nandi->base + NANDBCH_ADDRESS_REG_1, prog, 64);
-}
-
-static void bch_wait_seq(struct nandi_controller *nandi)
-{
-	int ret;
-
-	ret = wait_for_completion_timeout(&nandi->seq_completed, HZ/2);
-	if (!ret)
-		dev_err(nandi->dev, "BCH Seq timeout\n");
-}
-
-static uint8_t bch_erase_block(struct nandi_controller *nandi,
-			       loff_t offs)
-{
-	struct bch_prog *prog = &bch_prog_erase_block;
-	uint8_t status;
-
-	dev_dbg(nandi->dev, "%s: offs = 0x%012llx\n", __func__, offs);
-
-	prog->extra = (uint32_t)(offs >> nandi->page_shift);
-
-	emiss_nandi_select(STM_NANDI_BCH);
-
-	nandi_enable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-	INIT_COMPLETION(nandi->seq_completed);
-
-	bch_load_prog_cpu(nandi, prog);
-
-	bch_wait_seq(nandi);
-
-	nandi_disable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-
-	status = (uint8_t)(readl(nandi->base +
-				 NANDBCH_CHECK_STATUS_REG_A) & 0xff);
-
-	return status;
-}
-
-/* Attempt to establish if a page is empty (likely to have been erased), while
- * tolerating a number of bits stuck at, or drifted to, 0.
- */
-static int is_page_empty(uint8_t *data, uint32_t page_size, int max_bit_errors)
-{
-	int e = 0;
-
-	while (page_size--) {
-		e += hweight8(~*data++);
-		if (e > max_bit_errors)
-			return 0;
-	}
-
-	return 1;
-}
-
-/* Returns the number of ECC errors, or '-1' for uncorrectable error */
-static int bch_read_page(struct nandi_controller *nandi,
-			 loff_t offs,
-			 uint8_t *buf)
-{
-	struct bch_prog *prog = &bch_prog_read_page;
-	uint32_t page_size = nandi->info.mtd.writesize;
-	unsigned long list_phys;
-	unsigned long buf_phys;
-	uint32_t ecc_err;
-	int ret = 0;
-
-	dev_dbg(nandi->dev, "%s: offs = 0x%012llx\n", __func__, offs);
-
-	BUG_ON((unsigned long)buf & (NANDI_BCH_DMA_ALIGNMENT - 1));
-	BUG_ON(offs & (NANDI_BCH_DMA_ALIGNMENT - 1));
-
-	emiss_nandi_select(STM_NANDI_BCH);
-
-	nandi_enable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-	INIT_COMPLETION(nandi->seq_completed);
-
-	/* Reset ECC stats */
-	writel(CFG_RESET_ECC_ALL | CFG_ENABLE_AFM,
-	       nandi->base + NANDBCH_CONTROLLER_CFG);
-	writel(CFG_ENABLE_AFM, nandi->base + NANDBCH_CONTROLLER_CFG);
-
-	prog->addr = (uint32_t)((offs >> (nandi->page_shift - 8)) & 0xffffff00);
-
-	buf_phys = dma_map_single(NULL, buf, page_size, DMA_FROM_DEVICE);
-
-	memset(nandi->buf_list, 0x00, NANDI_BCH_BUF_LIST_SIZE);
-	nandi->buf_list[0] = buf_phys | (nandi->sectors_per_page - 1);
-
-	list_phys = dma_map_single(NULL, nandi->buf_list,
-				   NANDI_BCH_BUF_LIST_SIZE, DMA_TO_DEVICE);
-
-	writel(list_phys, nandi->base + NANDBCH_BUFFER_LIST_PTR);
-
-	bch_load_prog_cpu(nandi, prog);
-
-	bch_wait_seq(nandi);
-
-	nandi_disable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-
-	dma_unmap_single(NULL, list_phys, NANDI_BCH_BUF_LIST_SIZE,
-			 DMA_TO_DEVICE);
-	dma_unmap_single(NULL, buf_phys, page_size, DMA_FROM_DEVICE);
-
-	/* Use the maximum per-sector ECC count! */
-	ecc_err = readl(nandi->base + NANDBCH_ECC_SCORE_REG_A) & 0xff;
-	if (ecc_err == 0xff) {
-		/* Do we have a genuine uncorrectable ECC error, or is it just
-		 * an erased page?
-		 */
-		if (is_page_empty(buf, page_size, nandi->sectors_per_page)) {
-			dev_dbg(nandi->dev, "%s: detected uncorrectable error, "
-				"but looks like an erased page\n", __func__);
-			ret = 0;
-		} else {
-			ret = -1;
-		}
-	} else {
-		ret = (int)ecc_err;
-	}
-
-	return ret;
-}
-
-/* Returns the status of the NAND device following the write operation */
-static uint8_t bch_write_page(struct nandi_controller *nandi,
-			      loff_t offs, const uint8_t *buf)
-{
-	struct bch_prog *prog = &bch_prog_write_page;
-	uint32_t page_size = nandi->info.mtd.writesize;
-	uint8_t *p = (uint8_t *)buf;
-	unsigned long list_phys;
-	unsigned long buf_phys;
-	uint8_t status;
-
-	dev_dbg(nandi->dev, "%s: offs = 0x%012llx\n", __func__, offs);
-
-	BUG_ON((unsigned int)buf & (NANDI_BCH_DMA_ALIGNMENT - 1));
-	BUG_ON(offs & (page_size - 1));
-
-	emiss_nandi_select(STM_NANDI_BCH);
-
-	nandi_enable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-	INIT_COMPLETION(nandi->seq_completed);
-
-	prog->addr = (uint32_t)((offs >> (nandi->page_shift - 8)) & 0xffffff00);
-
-	buf_phys = dma_map_single(NULL, p, page_size, DMA_TO_DEVICE);
-	memset(nandi->buf_list, 0x00, NANDI_BCH_BUF_LIST_SIZE);
-	nandi->buf_list[0] = buf_phys | (nandi->sectors_per_page - 1);
-
-	list_phys = dma_map_single(NULL, nandi->buf_list,
-				   NANDI_BCH_BUF_LIST_SIZE, DMA_TO_DEVICE);
-
-	writel(list_phys, nandi->base + NANDBCH_BUFFER_LIST_PTR);
-
-	bch_load_prog_cpu(nandi, prog);
-
-	bch_wait_seq(nandi);
-
-	nandi_disable_interrupts(nandi, NANDBCH_INT_SEQNODESOVER);
-
-	dma_unmap_single(NULL, list_phys, NANDI_BCH_BUF_LIST_SIZE,
-			 DMA_TO_DEVICE);
-	dma_unmap_single(NULL, buf_phys, page_size, DMA_FROM_DEVICE);
-
-	status = (uint8_t)(readl(nandi->base +
-				 NANDBCH_CHECK_STATUS_REG_A) & 0xff);
-
-	return status;
-}
-
-/* Helper function for mtd_read, to handle multi-page or non-aligned reads */
-static int bch_read(struct nandi_controller *nandi,
-		    loff_t from, size_t len,
-		    size_t *retlen, u_char *buf)
-{
-	uint32_t page_size = nandi->info.mtd.writesize;
-	struct mtd_ecc_stats stats;
-	loff_t page_mask;
-	loff_t page_offs;
-	int page_num;
-	uint32_t col_offs;
-	int ecc_errs;
-	size_t bytes;
-	uint8_t *p;
-
-	int bounce;
-
-	dev_dbg(nandi->dev, "%s: %llu @ 0x%012llx\n", __func__,
-		(unsigned long long)len, from);
-
-	stats = nandi->info.mtd.ecc_stats;
-	page_mask = (loff_t)page_size - 1;
-	col_offs = (uint32_t)(from & page_mask);
-	page_offs = from & ~page_mask;
-	page_num = (int)(page_offs >> nandi->page_shift);
-
-	if (retlen)
-		*retlen = 0;
-
-	while (len > 0) {
-		bytes = min((page_size - col_offs), len);
-
-		if ((bytes != page_size) ||
-		    ((unsigned int)buf & (NANDI_BCH_DMA_ALIGNMENT - 1)) ||
-		    (!virt_addr_valid(buf))) /* vmalloc'd buffer! */
-			bounce = 1;
-		else
-			bounce = 0;
-
-		if (page_num == nandi->cached_page) {
-			memcpy(buf, nandi->page_buf + col_offs, bytes);
-		} else {
-			p = bounce ? nandi->page_buf : buf;
-
-			ecc_errs = bch_read_page(nandi, page_offs, p);
-			if (ecc_errs < 0) {
-				/* Might be better to break/return here... but
-				 * we follow approach in
-				 * nand_base.c:do_nand_read_ops()
-				 */
-				dev_err(nandi->dev, "%s: uncorrectable error "
-					"at 0x%012llx\n", __func__, page_offs);
-				nandi->info.mtd.ecc_stats.failed++;
-			} else {
-				if (ecc_errs) {
-					dev_info(nandi->dev, "%s: corrected %u "
-						 "error(s) at 0x%012llx\n",
-						 __func__, ecc_errs, page_offs);
-					nandi->info.mtd.ecc_stats.corrected +=
-						ecc_errs;
-				}
-			}
-
-			if (bounce) {
-				nandi->cached_page = page_num;
-				memcpy(buf, p + col_offs, bytes);
-			}
-		}
-
-		buf += bytes;
-		len -= bytes;
-
-		if (retlen)
-			*retlen += bytes;
-
-		/* We are now page-aligned */
-		page_offs += page_size;
-		page_num++;
-		col_offs = 0;
-	}
-
-	if (nandi->info.mtd.ecc_stats.failed - stats.failed)
-		return -EBADMSG;
-
-	if (nandi->info.mtd.ecc_stats.corrected - stats.corrected)
-		return -EUCLEAN;
-
-	return 0;
-}
-
-
-/* Helper function for mtd_write, to handle multi-page and non-aligned writes */
-static int bch_write(struct nandi_controller *nandi,
-		     loff_t to, size_t len,
-		     size_t *retlen, const uint8_t *buf)
-{
-	uint32_t page_size = nandi->info.mtd.writesize;
-	int bounce;
-	const uint8_t *p = NULL;
-
-	dev_dbg(nandi->dev, "%s: %llu @ 0x%012llx\n", __func__,
-		(unsigned long long)len, to);
-
-	BUG_ON(len & (page_size - 1));
-	BUG_ON(to & (page_size - 1));
-
-	if (((unsigned long)buf & (NANDI_BCH_DMA_ALIGNMENT - 1)) ||
-	    !virt_addr_valid(buf)) { /* vmalloc'd buffer! */
-		bounce = 1;
-	} else {
-		bounce = 0;
-	}
-
-	if (retlen)
-		*retlen = 0
-			;
-	while (len > 0) {
-
-		if (bounce) {
-			memcpy(nandi->page_buf, buf, page_size);
-			p = nandi->page_buf;
-			nandi->cached_page = -1;
-		} else {
-			p = buf;
-		}
-
-		if (bch_write_page(nandi, to, p) & NAND_STATUS_FAIL)
-			return -EIO;
-
-		to += page_size;
-		buf += page_size;
-		len -= page_size;
-
-		if (retlen)
-			*retlen += page_size;
-	}
-
-	return 0;
-}
-
-/*
- * Hamming-FLEX operations
- */
-static int flex_wait_rbn(struct nandi_controller *nandi)
-{
-	int ret;
-
-	ret = wait_for_completion_timeout(&nandi->rbn_completed, HZ/2);
-	if (!ret)
-		dev_err(nandi->dev, "FLEX RBn timeout\n");
-
-	return ret;
-}
-
-static void flex_cmd(struct nandi_controller *nandi, uint8_t cmd)
-{
-	uint32_t val;
-
-	val = (FLEX_CMD_CSN | FLEX_CMD_BEATS_1 | cmd);
-
-	writel(val, nandi->base + NANDHAM_FLEX_CMD);
-}
-
-static void flex_addr(struct nandi_controller *nandi,
-		      uint32_t addr, int cycles)
-{
-	addr &= 0x00ffffff;
-
-	BUG_ON(cycles < 1);
-	BUG_ON(cycles > 3);
-
-	addr |= (FLEX_ADDR_CSN | FLEX_ADDR_ADD8_VALID);
-	addr |= (cycles & 0x3) << 28;
-
-	writel(addr, nandi->base + NANDHAM_FLEX_ADD);
-}
-
-/*
- * Partial implementation of MTD/NAND Interface, based on Hamming-FLEX
- * operation.
- *
- * Allows us to make use of nand_base.c functions where possible
- * (e.g. nand_scan_ident() and friends).
- */
-static void flex_command_lp(struct mtd_info *mtd, unsigned int command,
-			    int column, int page)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	switch (command) {
-	case NAND_CMD_READOOB:
-		/* Emulate NAND_CMD_READOOB */
-		column += mtd->writesize;
-		command = NAND_CMD_READ0;
-		break;
-	case NAND_CMD_READ0:
-	case NAND_CMD_ERASE1:
-	case NAND_CMD_SEQIN:
-	case NAND_CMD_RESET:
-	case NAND_CMD_PARAM:
-		/* Prime RBn wait */
-		nandi_enable_interrupts(nandi, NAND_INT_RBN);
-		INIT_COMPLETION(nandi->rbn_completed);
-		break;
-	case NAND_CMD_READID:
-	case NAND_CMD_STATUS:
-	case NAND_CMD_ERASE2:
-		break;
-	default:
-		/* Catch unexpected commands */
-		BUG();
-	}
-
-	/*
-	 * Command Cycle
-	 */
-	flex_cmd(nandi, command);
-
-	/*
-	 * Address Cycles
-	 */
-	if (column != -1)
-		flex_addr(nandi, column,
-			  (command == NAND_CMD_READID) ? 1 : 2);
-	if (page != -1)
-		flex_addr(nandi, page, (chip->chipsize > (128 << 20)) ? 3 : 2);
-
-	/* Complete 'READ0' command */
-	if (command == NAND_CMD_READ0)
-		flex_cmd(nandi, NAND_CMD_READSTART);
-
-	/* Wait for RBn, if required.  (Note, other commands may handle wait
-	 * elsewhere)
-	 */
-	if (command == NAND_CMD_RESET ||
-	    command == NAND_CMD_READ0 ||
-	    command == NAND_CMD_PARAM) {
-		flex_wait_rbn(nandi);
-		nandi_disable_interrupts(nandi, NAND_INT_RBN);
-	}
-
-}
-
-static uint8_t flex_read_byte(struct mtd_info *mtd)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	return (uint8_t)(readl(nandi->base + NANDHAM_FLEX_DATA) & 0xff);
-}
-
-static int flex_wait_func(struct mtd_info *mtd, struct nand_chip *chip)
-{
-	struct nandi_controller *nandi = chip->priv;
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	flex_wait_rbn(nandi);
-
-	flex_cmd(nandi, NAND_CMD_STATUS);
-
-	return (int)(readl(nandi->base + NANDHAM_FLEX_DATA) & 0xff);
-}
-
-/* Multi-CS devices not supported */
-static void flex_select_chip(struct mtd_info *mtd, int chipnr)
-{
-
-}
-
-static void flex_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	int aligned;
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	/* Read bytes until buf is 4-byte aligned */
-	while (len && ((unsigned int)buf & 0x3)) {
-		*buf++ = (uint8_t)(readl(nandi->base + NANDHAM_FLEX_DATA)
-				   & 0xff);
-		len--;
-	};
-
-	/* Use 'BEATS_4'/readsl */
-	if (len > 8) {
-		aligned = len & ~0x3;
-		writel(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-
-		readsl(nandi->base + NANDHAM_FLEX_DATA, buf, aligned >> 2);
-
-		buf += aligned;
-		len -= aligned;
-
-		writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-	}
-
-	/* Mop up remaining bytes */
-	while (len > 0) {
-		*buf++ = (uint8_t)(readl(nandi->base + NANDHAM_FLEX_DATA)
-				   & 0xff);
-		len--;
-	}
-}
-
-static void flex_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	int aligned;
-
-	/* Write bytes until buf is 4-byte aligned */
-	while (len && ((unsigned int)buf & 0x3)) {
-		writel(*buf++, nandi->base + NANDHAM_FLEX_DATA);
-		len--;
-	};
-
-	/* USE 'BEATS_4/writesl */
-	if (len > 8) {
-		aligned = len & ~0x3;
-		writel(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		       nandi->base + NANDHAM_FLEX_DATAWRITE_CONFIG);
-		writesl(nandi->base + NANDHAM_FLEX_DATA, buf, aligned >> 2);
-		buf += aligned;
-		len -= aligned;
-		writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		       nandi->base + NANDHAM_FLEX_DATAWRITE_CONFIG);
-	}
-
-	/* Mop up remaining bytes */
-	while (len > 0) {
-		writel(*buf++, nandi->base + NANDHAM_FLEX_DATA);
-		len--;
-	}
-}
-
-/* Catch calls to non-supported functions */
-static uint16_t flex_read_word_BUG(struct mtd_info *mtd)
-{
-	BUG();
-
-	return 0;
-}
-
-static int flex_block_bad_BUG(struct mtd_info *mtd, loff_t ofs, int getchip)
-{
-	BUG();
-
-	return 1;
-}
-
-static int flex_block_markbad_BUG(struct mtd_info *mtd, loff_t ofs)
-{
-	BUG();
-
-	return 1;
-}
-
-static int flex_verify_buf_BUG(struct mtd_info *mtd, const uint8_t *buf,
-			       int len)
-{
-	BUG();
-
-	return 1;
-}
-
-int flex_scan_bbt_BUG(struct mtd_info *mtd)
-{
-	BUG();
-
-	return 1;
-}
-
-
-/*
- * Hamming-FLEX operations (optimised replacements for nand_base.c versions)
- */
-static int flex_check_wp(struct nandi_controller *nandi)
-{
-	uint8_t status;
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	flex_cmd(nandi, NAND_CMD_STATUS);
-
-	status = (uint8_t)(readl(nandi->base + NANDHAM_FLEX_DATA) & 0xff);
-
-	return status & NAND_STATUS_WP ? 0 : 1;
-}
-
-static int flex_read_raw(struct nandi_controller *nandi,
-			 uint32_t page_addr,
-			 uint32_t col_addr,
-			 uint8_t *buf, uint32_t len)
-{
-	dev_dbg(nandi->dev, "%s %u bytes at [0x%06x,0x%04x]\n",
-		__func__, len, page_addr, col_addr);
-
-	BUG_ON(len & 0x3);
-	BUG_ON((unsigned long)buf & 0x3);
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-	nandi_enable_interrupts(nandi, NAND_INT_RBN);
-	INIT_COMPLETION(nandi->rbn_completed);
-
-	writel(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-
-	flex_cmd(nandi, NAND_CMD_READ0);
-	flex_addr(nandi, col_addr, 2);
-	flex_addr(nandi, page_addr, 3);
-	flex_cmd(nandi, NAND_CMD_READSTART);
-
-	flex_wait_rbn(nandi);
-
-	readsl(nandi->base + NANDHAM_FLEX_DATA, buf, len/4);
-
-	nandi_disable_interrupts(nandi, NAND_INT_RBN);
-
-	writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-
-	return 0;
-}
-
-static int flex_write_raw(struct nandi_controller *nandi,
-			  uint32_t page_addr,
-			  uint32_t col_addr,
-			  uint8_t *buf, uint32_t len)
-{
-	uint8_t status;
-
-	dev_dbg(nandi->dev, "%s %u bytes at [0x%06x,0x%04x]\n",
-		__func__, len, page_addr, col_addr);
-
-	BUG_ON(len & 0x3);
-	BUG_ON((unsigned long)buf & 0x3);
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-	nandi_enable_interrupts(nandi, NAND_INT_RBN);
-	INIT_COMPLETION(nandi->rbn_completed);
-
-	writel(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAWRITE_CONFIG);
-
-	flex_cmd(nandi, NAND_CMD_SEQIN);
-	flex_addr(nandi, col_addr, 2);
-	flex_addr(nandi, page_addr, 3);
-
-	writesl(nandi->base + NANDHAM_FLEX_DATA, buf, len/4);
-
-	flex_cmd(nandi, NAND_CMD_PAGEPROG);
-
-	flex_wait_rbn(nandi);
-
-	nandi_disable_interrupts(nandi, NAND_INT_RBN);
-
-	writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAWRITE_CONFIG);
-
-	flex_cmd(nandi, NAND_CMD_STATUS);
-
-	status = (uint8_t)(readl(nandi->base + NANDHAM_FLEX_DATA) & 0xff);
-
-	return status;
-}
-
-/*
- * Bad Block Tables/Bad Block Markers
- */
-#define BBT_MARK_BAD_FACTORY	0x0
-#define BBT_MARK_BAD_WEAR	0x1
-#define BBT_MARK_GOOD		0x3
-static void bbt_set_block_mark(uint8_t *bbt, uint32_t block, uint8_t mark)
-{
-	unsigned int byte = block >> 2;
-	unsigned int shift = (block & 0x3) << 1;
-
-	bbt[byte] &= ~(0x3 << shift);
-	bbt[byte] |= ((mark & 0x3) << shift);
-}
-
-static uint8_t bbt_get_block_mark(uint8_t *bbt, uint32_t block)
-{
-	unsigned int byte = block >> 2;
-	unsigned int shift = (block & 0x3) << 1;
-
-	return (bbt[byte] >> shift) & 0x3;
-}
-
-static int bbt_is_block_bad(uint8_t *bbt, uint32_t block)
-{
-	return bbt_get_block_mark(bbt, block) == BBT_MARK_GOOD ? 0 : 1;
-}
-
-/* Scan page for BBM(s), according to specified scheme */
-static int nandi_scan_bad_block_markers_page(struct nandi_controller *nandi,
-					     uint32_t page,
-					     uint32_t bbm_scheme)
-{
-	struct mtd_info *mtd = &nandi->info.mtd;
-	uint8_t *oob_buf = nandi->oob_buf;
-	int i;
-	int ret = 0;
-
-	/* Read the OOB area */
-	flex_read_raw(nandi, page, mtd->writesize, oob_buf, mtd->oobsize);
-
-	/* Check for markers */
-	if (bbm_scheme & NAND_BBM_BYTE_OOB_ALL) {
-		for (i = 0; i < mtd->oobsize; i++)
-			if (oob_buf[i] != 0xff) {
-				ret = 1;
-				break;
-			}
-	} else if (((bbm_scheme & NAND_BBM_BYTE_OOB_0) &&
-		    (oob_buf[0] != 0xff)) ||
-		   ((bbm_scheme & NAND_BBM_BYTE_OOB_5) &&
-		    (oob_buf[5] != 0xff))) {
-		ret = 1;
-	}
-
-#ifdef NANDI_BBM_TOLERATE_BCH_DATA
-	/* Check for valid BCH ECC data by performing a page read */
-	if (ret == 1) {
-		loff_t offs = (loff_t)page << nandi->page_shift;
-		uint8_t *page_buf = nandi->page_buf;
-
-		nandi->cached_page = -1;
-		if (bch_read_page(nandi, offs, page_buf) >= 0) {
-			/* All 0x00s leads to valid BCH ECC, but likely to be
-			 * bad-block marker */
-			ret = 0;
-			for (i = 0; i < mtd->writesize; i++) {
-				if (page_buf[i] != 0x00) {
-					ret = 1;
-					break;
-				}
-			}
-
-			/* No uncorrectable errors, assume valid BCH ECC data */
-			if (ret == 0)
-				dev_info(nandi->dev, "BBM @ 0x%012llx: valid "
-					 "BCH ECC data, treat as good\n", offs);
-		}
-	}
-#endif
-
-	return ret;
-}
-
-/* Scan block for BBM(s), according to specified scheme */
-static int nandi_scan_bad_block_markers_block(struct nandi_controller *nandi,
-					      uint32_t block,
-					      uint32_t bbm_scheme)
-
-{
-	struct mtd_info *mtd = &nandi->info.mtd;
-	uint32_t pages_per_block = mtd->erasesize >> nandi->page_shift;
-	uint32_t page = block << (nandi->block_shift - nandi->page_shift);
-
-	if (nandi_scan_bad_block_markers_page(nandi, page, bbm_scheme))
-		return 1;
-
-	if ((bbm_scheme & NAND_BBM_PAGE_1) &&
-	    nandi_scan_bad_block_markers_page(nandi, page + 1, bbm_scheme))
-		return 1;
-
-	if ((bbm_scheme & NAND_BBM_PAGE_LAST) &&
-	    nandi_scan_bad_block_markers_page(nandi, page + pages_per_block - 1,
-					      bbm_scheme))
-		return 1;
-
-	return 0;
-}
-
-/* Scan for BBMs and build memory-resident BBT */
-static int nandi_scan_build_bbt(struct nandi_controller *nandi,
-				struct nandi_bbt_info *bbt_info,
-				uint32_t bbm_scheme)
-{
-	uint32_t page_size = nandi->info.mtd.writesize;
-	uint8_t *bbt = bbt_info->bbt;
-	uint32_t block;
-
-	dev_dbg(nandi->dev, "scan device for bad-block markers "
-		"[scheme = 0x%02x]\n", bbm_scheme);
-
-	memset(bbt, 0xff, page_size);
-	bbt_info->bbt_vers[0] = 0;
-	bbt_info->bbt_vers[1] = 0;
-	bbt_info->bbt_block[0] = nandi->blocks_per_device - 1;
-	bbt_info->bbt_block[1] = nandi->blocks_per_device - 2;
-
-	for (block = 0; block < nandi->blocks_per_device; block++)
-		if (nandi_scan_bad_block_markers_block(nandi, block,
-						       bbm_scheme))
-			bbt_set_block_mark(bbt, block, BBT_MARK_BAD_FACTORY);
-
-	return 0;
-}
-
-/* Populate IBBT BCH Header */
-static void bch_fill_ibbt_header(struct nandi_controller *nandi,
-				 struct nand_ibbt_bch_header *ibbt_header,
-				 int bak, uint8_t vers)
-{
-	const char author[] = "STLinux " UTS_RELEASE " (stm-nand-bch)";
-
-	memcpy(ibbt_header->base.signature, ibbt_sigs[bak], NAND_IBBT_SIGLEN);
-	ibbt_header->base.version = vers;
-	memset(ibbt_header->base.schema, NAND_IBBT_SCHEMA, 4);
-
-	memset(ibbt_header->schema, NAND_IBBT_SCHEMA, 4);
-	memset(ibbt_header->ecc_size, bch_ecc_sizes[nandi->bch_ecc_mode], 4);
-	memcpy(ibbt_header->author, author, sizeof(author));
-}
-
-/* Write IBBT to Flash */
-static int bch_write_bbt_data(struct nandi_controller *nandi,
-			      struct nandi_bbt_info *bbt_info,
-			      uint32_t block, int bak, uint8_t vers)
-{
-	uint32_t page_size = nandi->info.mtd.writesize;
-	uint32_t block_size = nandi->info.mtd.erasesize;
-	struct nand_ibbt_bch_header *ibbt_header =
-		(struct nand_ibbt_bch_header *)nandi->page_buf;
-	loff_t offs;
-
-	nandi->cached_page = -1;
-
-	/* Write BBT contents to first page of block*/
-	offs = (loff_t)block << nandi->block_shift;
-	if (bch_write_page(nandi, offs, bbt_info->bbt) & NAND_STATUS_FAIL)
-		return 1;
-
-	/* Update IBBT header and write to last page of block */
-	memset(ibbt_header, 0xff, nandi->info.mtd.writesize);
-	bch_fill_ibbt_header(nandi, ibbt_header, bak, vers);
-	offs += block_size - page_size;
-	if (bch_write_page(nandi, offs, (uint8_t *)ibbt_header) &
-	    NAND_STATUS_FAIL)
-		return 1;
-
-	return 0;
-}
-
-/* Update Flash-resident BBT: erase/search suitable block, and write table
- * data to Flash */
-static int bch_update_bbt(struct nandi_controller *nandi,
-			 struct nandi_bbt_info *bbt_info,
-			 int bak, uint8_t vers)
-{
-	loff_t offs;
-	uint32_t block;
-	uint32_t block_lower;
-	uint32_t block_other;
-
-	block_other = bbt_info->bbt_block[(bak+1)%2];
-	block_lower = nandi->blocks_per_device - NAND_IBBT_NBLOCKS;
-
-	for (block = bbt_info->bbt_block[bak]; block >= block_lower;  block--) {
-		offs = (loff_t)block << nandi->block_shift;
-
-		/* Skip if block used by other table */
-		if (block == block_other)
-			continue;
-
-		/* Skip if block is marked bad */
-		if (bbt_is_block_bad(bbt_info->bbt, block))
-			continue;
-
-		/* Erase block, mark bad and skip on failure */
-		if (bch_erase_block(nandi, offs) & NAND_STATUS_FAIL) {
-			dev_info(nandi->dev, "failed to erase block "
-				 "[%u:0x%012llx] while updating BBT\n",
-				 block, offs);
-			vers++;
-			bbt_set_block_mark(bbt_info->bbt, block,
-					   BBT_MARK_BAD_WEAR);
-			continue;
-		}
-
-		/* Write BBT, mark bad and skip on failure */
-		if (bch_write_bbt_data(nandi, bbt_info, block, bak, vers)) {
-			dev_info(nandi->dev, "failed to write BBT to block"
-				 "[%u:0x%012llx]\n", block, offs);
-			vers++;
-			bbt_set_block_mark(bbt_info->bbt, block,
-					   BBT_MARK_BAD_WEAR);
-			continue;
-		}
-
-		/* Success */
-		bbt_info->bbt_block[bak] = block;
-		bbt_info->bbt_vers[bak] = vers;
-		break;
-	}
-
-	/* No space in BBT area */
-	if (block < block_lower) {
-		dev_err(nandi->dev, "no space left in BBT area\n");
-		dev_err(nandi->dev, "failed to update %s BBT\n", bbt_strs[bak]);
-		return -ENOSPC;
-	}
-
-	dev_info(nandi->dev, "wrote BBT [%s:%u] at 0x%012llx [%u]\n",
-		 bbt_strs[bak], vers, offs, block);
-
-	return 0;
-}
-
-#define NAND_IBBT_UPDATE_PRIMARY	0x1
-#define NAND_IBBT_UPDATE_MIRROR		0x2
-#define NAND_IBBT_UPDATE_BOTH		(NAND_IBBT_UPDATE_PRIMARY | \
-					 NAND_IBBT_UPDATE_MIRROR)
-static char *bbt_update_strs[] = {
-	"",
-	"primary",
-	"mirror",
-	"both",
-};
-
-/* Update Flash-resident BBT(s), incrementing 'vers' number if required, and
- * ensuring Primary and Mirror are kept in sync */
-static int bch_update_bbts(struct nandi_controller *nandi,
-			   struct nandi_bbt_info *bbt_info,
-			   unsigned int update, uint8_t vers)
-{
-	int err;
-
-	dev_info(nandi->dev, "updating %s BBT(s)\n", bbt_update_strs[update]);
-
-	do {
-		/* Update Primary if specified */
-		if (update & NAND_IBBT_UPDATE_PRIMARY) {
-			err = bch_update_bbt(nandi, bbt_info, NAND_IBBT_PRIMARY,
-					     vers);
-			/* Bail out on error (e.g. no space left in BBT area) */
-			if (err)
-				return err;
-
-			/* If update resulted in a new BBT version
-			 * (e.g. Erase/Write fail on BBT block) update version
-			 * here, and force update of other table.
-			 */
-			if (bbt_info->bbt_vers[NAND_IBBT_PRIMARY] != vers) {
-				vers = bbt_info->bbt_vers[NAND_IBBT_PRIMARY];
-				update = NAND_IBBT_UPDATE_MIRROR;
-			}
-		}
-
-		/* Update Mirror if specified */
-		if (update & NAND_IBBT_UPDATE_MIRROR) {
-			err = bch_update_bbt(nandi, bbt_info, NAND_IBBT_MIRROR,
-					     vers);
-			/* Bail out on error (e.g. no space left in BBT area) */
-			if (err)
-				return err;
-
-			/* If update resulted in a new BBT version
-			 * (e.g. Erase/Write fail on BBT block) update version
-			 * here, and force update of other table.
-			 */
-			if (bbt_info->bbt_vers[NAND_IBBT_MIRROR] != vers) {
-				vers = bbt_info->bbt_vers[NAND_IBBT_MIRROR];
-				update = NAND_IBBT_UPDATE_PRIMARY;
-			}
-		}
-
-		/* Continue, until Primary and Mirror versions are in sync */
-	} while (bbt_info->bbt_vers[NAND_IBBT_PRIMARY] !=
-		 bbt_info->bbt_vers[NAND_IBBT_MIRROR]);
-
-	return 0;
-}
-
-/* Scan block for IBBT signature */
-static int bch_find_ibbt_sig(struct nandi_controller *nandi,
-			     uint32_t block, int *bak, uint8_t *vers,
-			     char *author)
-{
-	struct mtd_info *mtd = &nandi->info.mtd;
-	struct nand_ibbt_bch_header *ibbt_header;
-	loff_t offs;
-	uint8_t *buf = nandi->page_buf;
-	int match_sig;
-	unsigned int b;
-	unsigned int i;
-
-	nandi->cached_page = -1;
-
-	/* Load last page of block */
-	offs = 	(loff_t)block << nandi->block_shift;
-	offs += mtd->erasesize - mtd->writesize;
-	if (bch_read_page(nandi, offs, buf) < 0) {
-		dev_info(nandi->dev, "Uncorrectable ECC error while scanning "
-			 "BBT signature at block %u [0x%012llx]\n",
-			 block, offs);
-		return 0;
-	}
-	ibbt_header = (struct nand_ibbt_bch_header *)buf;
-
-	/* Test IBBT signature */
-	match_sig = 0;
-	for (b = 0; b < 2 && !match_sig; b++) {
-		match_sig = 1;
-		for (i = 0; i < NAND_IBBT_SIGLEN; i++) {
-			if (ibbt_header->base.signature[i] != ibbt_sigs[b][i]) {
-				match_sig = 0;
-				break;
-			}
-		}
-
-	}
-
-	if (!match_sig)
-		return 0; /* Failed to match IBBT signature */
-
-	/* Test IBBT schema */
-	for (i = 0; i < 4; i++)
-		if (ibbt_header->base.schema[i] != NAND_IBBT_SCHEMA)
-			return 0;
-
-	/* Test IBBT BCH schema */
-	for (i = 0; i < 4; i++)
-		if (ibbt_header->schema[i] != NAND_IBBT_BCH_SCHEMA)
-			return 0;
-
-	/* We have a match */
-	*vers = ibbt_header->base.version;
-	*bak = b - 1;
-	strncpy(author, ibbt_header->author, 64);
-
-	return 1;
-}
-
-/* Search for, and load Flash-resident BBT, updating Primary/Mirror if
- * required
- */
-static int bch_load_bbt(struct nandi_controller *nandi,
-			struct nandi_bbt_info *bbt_info)
-{
-	unsigned int update = 0;
-	uint32_t block;
-	loff_t offs;
-	uint8_t vers;
-	char author[64];
-	int bak;
-
-	dev_dbg(nandi->dev, "looking for Flash-resident BBTs\n");
-
-	bbt_info->bbt_block[0] = 0;
-	bbt_info->bbt_block[1] = 0;
-	bbt_info->bbt_vers[0] = 0;
-	bbt_info->bbt_vers[1] = 0;
-
-	/* Look for IBBT signatures */
-	for (block = nandi->blocks_per_device - NAND_IBBT_NBLOCKS;
-	     block < nandi->blocks_per_device;
-	     block++) {
-		offs = (loff_t)block << nandi->block_shift;
-
-		if (bch_find_ibbt_sig(nandi, block, &bak, &vers, author)) {
-			dev_dbg(nandi->dev, "found BBT [%s:%u] at 0x%012llx "
-				"[%u] (%s)\n", bbt_strs[bak], vers, offs, block,
-				author);
-
-			if (bbt_info->bbt_block[bak] == 0 ||
-			    ((int8_t)(bbt_info->bbt_vers[bak] - vers)) < 0) {
-				bbt_info->bbt_block[bak] = block;
-				bbt_info->bbt_vers[bak] = vers;
-			}
-		}
-	}
-
-	/* What have we found? */
-	if (bbt_info->bbt_block[0] == 0 && bbt_info->bbt_block[1] == 0) {
-		/* no primary, no mirror: return error*/
-		return 1;
-	} else if (bbt_info->bbt_block[0] == 0) {
-		/* no primary: use mirror, update primary */
-		bak = 1;
-		update = NAND_IBBT_UPDATE_PRIMARY;
-		bbt_info->bbt_block[0] = nandi->blocks_per_device - 1;
-	} else if (bbt_info->bbt_block[1] == 0) {
-		/* no mirror: use primary, update mirror */
-		bak = 0;
-		update = NAND_IBBT_UPDATE_MIRROR;
-		bbt_info->bbt_block[1] = nandi->blocks_per_device - 1;
-	} else if (bbt_info->bbt_vers[0] == bbt_info->bbt_vers[1]) {
-		/* primary == mirror: use primary, no update required */
-		bak = 0;
-	} else if ((int8_t)(bbt_info->bbt_vers[1] -
-			    bbt_info->bbt_vers[0]) < 0) {
-		/* primary > mirror: use primary, update mirror */
-		bak = 0;
-		update = NAND_IBBT_UPDATE_MIRROR;
-	} else {
-		/* mirror > primary: use mirror, update primary */
-		bak = 1;
-		update = NAND_IBBT_UPDATE_PRIMARY;
-	}
-
-	vers = bbt_info->bbt_vers[bak];
-	block = bbt_info->bbt_block[bak];
-	offs = block << nandi->block_shift;
-	dev_info(nandi->dev, "using BBT [%s:%u] at 0x%012llx [%u]\n",
-		 bbt_strs[bak], vers, offs, block);
-
-	/* Read BBT data */
-	if (bch_read_page(nandi, offs, bbt_info->bbt) < 0) {
-		dev_err(nandi->dev, "error while reading BBT %s:%u] at "
-			"0x%012llx [%u]\n", bbt_strs[bak], vers, offs, block);
-		return 1;
-	}
-
-	/* Update other BBT if required */
-	if (update)
-		bch_update_bbts(nandi, bbt_info, update, vers);
-
-	return 0;
-}
-
-
-/*
- * MTD Interface: Standard set of callbacks for MTD functionality
- */
-static int mtd_read(struct mtd_info *mtd, loff_t from, size_t len,
-		    size_t *retlen, uint8_t *buf)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	int ret;
-
-	dev_dbg(nandi->dev, "%s: %llu @ 0x%012llx\n", __func__,
-		(unsigned long long)len, from);
-
-	if (retlen)
-		*retlen = 0;
-
-	if ((from + len) > mtd->size)
-		return -EINVAL;
-	if (!len)
-		return 0;
-
-	nand_get_device(chip, mtd, FL_READING);
-
-	ret = bch_read(nandi, from, len, retlen, buf);
-
-	nand_release_device(mtd);
-
-	return ret;
-}
-
-static int mtd_write(struct mtd_info *mtd, loff_t to, size_t len,
-			  size_t *retlen, const uint8_t *buf)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	uint32_t page_mask = mtd->writesize - 1;
-
-	int ret;
-
-	dev_dbg(nandi->dev, "%s: %llu @ 0x%012llx\n", __func__,
-		(unsigned long long)len, to);
-
-	if (retlen)
-		*retlen = 0;
-
-	if ((to + len) > mtd->size)
-		return -EINVAL;
-	if (!len)
-		return 0;
-	if ((to & page_mask) || (len & page_mask)) {
-		dev_err(nandi->dev, "attempt to write non-page-aligned "
-			"data\n");
-		return -EINVAL;
-	}
-
-	nand_get_device(chip, mtd, FL_WRITING);
-
-	if (flex_check_wp(nandi)) {
-		dev_dbg(nandi->dev, "device is write-protected\n");
-		return -EIO;
-	}
-
-	ret = bch_write(nandi, to, len, retlen, buf);
-
-	nand_release_device(mtd);
-
-	return ret;
-
-}
-
-/* Helper function for mtd_read_oob(): handles multi-page transfers and mapping
- * between BCH sectors and MTD page+OOB data. */
-static int flex_do_read_ops(struct nandi_controller *nandi,
-				loff_t from,
-				struct mtd_oob_ops *ops)
-{
-	struct mtd_info *mtd = &nandi->info.mtd;
-	uint32_t page_addr = from >> nandi->page_shift;
-	int pages;
-	uint32_t oob_bytes_per_sector = mtd->oobsize / nandi->sectors_per_page;
-	uint32_t oob_pad_per_page = mtd->oobsize % nandi->sectors_per_page;
-	int ecc_size = bch_ecc_sizes[nandi->bch_ecc_mode];
-	uint8_t *o = ops->oobbuf;
-	uint8_t *p = ops->datbuf;
-	uint8_t *t;
-	int s;
-
-	nandi->cached_page = -1;
-
-	pages = ops->datbuf ?
-		(ops->len >> nandi->page_shift) :
-		(ops->ooblen / mtd->oobsize);
-
-	while (pages) {
-		t = nandi->page_buf;
-
-		flex_read_raw(nandi, page_addr, 0, t,
-			      mtd->writesize + mtd->oobsize);
-
-		for (s = 0; s < nandi->sectors_per_page; s++) {
-			if (p) {
-				memcpy(p, t, NANDI_BCH_SECTOR_SIZE);
-				p += NANDI_BCH_SECTOR_SIZE;
-				ops->retlen += NANDI_BCH_SECTOR_SIZE;
-			}
-			t += NANDI_BCH_SECTOR_SIZE;
-
-			if (o) {
-				memcpy(o, t, ecc_size);
-				memset(o + ecc_size, 0xff,
-				       oob_bytes_per_sector - ecc_size);
-
-				ops->oobretlen += oob_bytes_per_sector;
-				o += oob_bytes_per_sector;
-			}
-			t += ecc_size;
-		}
-
-		if (oob_pad_per_page && o) {
-			memset(o, 0xff, oob_pad_per_page);
-			o += oob_pad_per_page;
-		}
-
-		page_addr++;
-		pages--;
-	}
-
-	return 0;
-}
-
-/* Helper function for mtd_write_oob(): handles multi-page transfers and mapping
- * between BCH sectors and MTD page+OOB data. */
-static int flex_do_write_ops(struct nandi_controller *nandi,
-			     loff_t to,
-			     struct mtd_oob_ops *ops)
-{
-	struct mtd_info *mtd = &nandi->info.mtd;
-	uint32_t page_addr = to >> nandi->page_shift;
-	int pages;
-	uint32_t oob_bytes_per_sector = mtd->oobsize / nandi->sectors_per_page;
-	uint32_t oob_pad_per_page = mtd->oobsize % nandi->sectors_per_page;
-	int ecc_size = bch_ecc_sizes[nandi->bch_ecc_mode];
-	uint8_t *o = ops->oobbuf;
-	uint8_t *p = ops->datbuf;
-	uint8_t *t;
-	uint8_t status;
-	int s;
-
-	nandi->cached_page = -1;
-
-	pages = ops->datbuf ?
-		(ops->len >> nandi->page_shift) :
-		(ops->ooblen / mtd->oobsize);
-
-	while (pages) {
-		t = nandi->page_buf;
-
-		for (s = 0; s < nandi->sectors_per_page; s++) {
-			if (p) {
-				memcpy(t, p, NANDI_BCH_SECTOR_SIZE);
-				p += NANDI_BCH_SECTOR_SIZE;
-				ops->retlen += NANDI_BCH_SECTOR_SIZE;
-			} else {
-				memset(t, 0xff, NANDI_BCH_SECTOR_SIZE);
-			}
-			t += NANDI_BCH_SECTOR_SIZE;
-
-			if (o) {
-				memcpy(t, o, ecc_size);
-				ops->oobretlen += oob_bytes_per_sector;
-				o += oob_bytes_per_sector;
-			} else {
-				memset(t, 0xff, ecc_size);
-			}
-			t += ecc_size;
-		}
-
-		if (oob_pad_per_page) {
-			memset(t, 0xff, oob_pad_per_page);
-			if (o)
-				o += oob_pad_per_page;
-		}
-
-		status = flex_write_raw(nandi, page_addr, 0, nandi->page_buf,
-					mtd->writesize + mtd->oobsize);
-
-		if (status & NAND_STATUS_FAIL)
-			return -EIO;
-
-		page_addr++;
-		pages--;
-	}
-
-	return 0;
-}
-
-static char *mtd_oob_mode_strs[] = {"PLACE", "AUTO", "RAW"};
-static int mtd_read_oob(struct mtd_info *mtd, loff_t from,
-			struct mtd_oob_ops *ops)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	uint32_t page_mask = mtd->writesize - 1;
-	int ret;
-
-	dev_dbg(nandi->dev, "%s: 0x%012llx [page = %u, oob = %u mode = %s]\n",
-		__func__, from,
-		(ops->datbuf ? ops->len : 0),
-		(ops->oobbuf ? ops->ooblen : 0),
-		mtd_oob_mode_strs[ops->mode]);
-
-	ops->oobretlen = 0;
-	ops->retlen = 0;
-
-	/* We report OOB as unavailable (i.e. oobavail = 0), therefore nothing
-	 * should call this */
-	if (ops->mode == MTD_OOB_AUTO)
-		return -ENOTSUPP;
-
-	/* Not currently supported by MTD.  Note, will have to fake support if
-	 * backporting 'in-band' nand_bbt.c... */
-	if (ops->datbuf && ops->mode == MTD_OOB_PLACE)
-		return -ENOTSUPP;
-
-	/* Do not allow oob reads with ooboffs */
-	if (ops->oobbuf && ops->ooboffs)
-		return -ENOTSUPP;
-
-	/* Do not allow reads past end of device */
-	if (ops->datbuf && (from + ops->len) > mtd->size) {
-		dev_err(nandi->dev, "attempt read beyond end of device\n");
-		return -EINVAL;
-	}
-	if (ops->oobbuf &&
-	    (from + mtd->writesize * (ops->ooblen / mtd->oobsize))
-	    > mtd->size) {
-		dev_err(nandi->dev, "attempt read beyond end of device\n");
-		return -EINVAL;
-	}
-
-	/* Do not allow non-aligned reads.  Note, might be sensible to support
-	 * oob-only or data-only non-aligned reads, but have seen no use-cases
-	 * so far. */
-	if ((from & page_mask) ||
-	    (ops->datbuf && (ops->len & page_mask)) ||
-	    (ops->oobbuf && (ops->ooblen % mtd->oobsize))) {
-		dev_err(nandi->dev, "attempt to read non-aligned data\n");
-		return -ENOTSUPP;
-	}
-
-	/* Do not allow inconsistent data and oob lengths */
-	if (ops->datbuf && ops->oobbuf &&
-	    (ops->len / mtd->writesize != ops->ooblen / mtd->oobsize)) {
-		dev_err(nandi->dev, "data length inconsistent with oob "
-			"length\n");
-		return -EINVAL;
-	}
-
-	nand_get_device(chip, mtd, FL_READING);
-
-	ret = flex_do_read_ops(nandi, from, ops);
-
-	nand_release_device(mtd);
-
-	return ret;
-}
-
-static int mtd_write_oob(struct mtd_info *mtd, loff_t to,
-			  struct mtd_oob_ops *ops)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-	uint32_t page_mask = mtd->writesize - 1;
-	int ret;
-
-	dev_dbg(nandi->dev, "%s: 0x%012llx [page = %u, oob = %u mode = %s]\n",
-		__func__, to,
-		(ops->datbuf ? ops->len : 0),
-		(ops->oobbuf ? ops->ooblen : 0),
-		mtd_oob_mode_strs[ops->mode]);
-
-	ops->oobretlen = 0;
-	ops->retlen = 0;
-
-	/* We report OOB as unavailable (i.e. oobavail = 0), therefore nothing
-	 * should call this */
-	if (ops->mode == MTD_OOB_AUTO)
-		return -ENOTSUPP;
-
-	/* Not currently supported by MTD.  Note, will have to fake support if
-	 * backporting wavefront nand_bbt.c... */
-	if (ops->datbuf && ops->mode == MTD_OOB_PLACE)
-		return -ENOTSUPP;
-
-	/* Do not allow oob writes with ooboffs */
-	if (ops->oobbuf && ops->ooboffs)
-		return -ENOTSUPP;
-
-	/* Do not allow writes past end of device */
-	if (ops->datbuf && (to + ops->len) > mtd->size) {
-		dev_err(nandi->dev, "attempt write beyond end of device\n");
-		return -EINVAL;
-	}
-	if (ops->oobbuf &&
-	    (to + mtd->writesize * (ops->ooblen / mtd->oobsize)) > mtd->size) {
-		dev_err(nandi->dev, "attempt write beyond end of device\n");
-		return -EINVAL;
-	}
-
-	/* Do not allow non-aligned writes */
-	if ((to & page_mask) ||
-	    (ops->datbuf && (ops->len & page_mask)) ||
-	    (ops->oobbuf && (ops->ooblen % mtd->oobsize))) {
-		dev_err(nandi->dev, "attempt to write non-aligned data\n");
-		return -EINVAL;
-	}
-
-	/* Do not allow inconsistent data and oob lengths */
-	if (ops->datbuf && ops->oobbuf &&
-	    (ops->len / mtd->writesize != ops->ooblen / mtd->oobsize)) {
-		dev_err(nandi->dev, "data length inconsistent with oob "
-			"length\n");
-		return -EINVAL;
-	}
-
-	nand_get_device(chip, mtd, FL_WRITING);
-
-	if (flex_check_wp(nandi)) {
-		dev_dbg(nandi->dev, "device is write-protected\n");
-		return -EIO;
-	}
-
-	ret = flex_do_write_ops(nandi, to, ops);
-
-	nand_release_device(mtd);
-
-	return ret;
-}
-
-static int mtd_block_isbad(struct mtd_info *mtd, loff_t offs)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-
-	uint32_t block;
-
-	/* Check for invalid offset */
-	if (offs > mtd->size)
-		return -EINVAL;
-
-	block = offs >> nandi->block_shift;
-
-	/* Protect blocks reserved for BBTs */
-	if (block >= (nandi->blocks_per_device - NAND_IBBT_NBLOCKS))
-		return 1;
-
-	return bbt_is_block_bad(nandi->info.bbt_info.bbt, block);
-}
-
-static int mtd_block_markbad(struct mtd_info *mtd, loff_t offs)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-
-	uint32_t block;
-	int ret;
-
-	/* Is block already considered bad? (will also catch invalid offsets) */
-	ret = mtd_block_isbad(mtd, offs);
-	if (ret < 0)
-		return ret;
-	if (ret == 1)
-		return 0;
-
-	/* Mark bad */
-	block = offs >> nandi->block_shift;
-	bbt_set_block_mark(nandi->info.bbt_info.bbt, block, BBT_MARK_BAD_WEAR);
-
-	/* Update BBTs, incrementing bbt_vers */
-	nand_get_device(chip, mtd, FL_WRITING);
-	ret = bch_update_bbts(nandi, &nandi->info.bbt_info,
-			      NAND_IBBT_UPDATE_BOTH,
-			      nandi->info.bbt_info.bbt_vers[0] + 1);
-	nand_release_device(mtd);
-
-	return ret;
-}
-
-static int mtd_erase(struct mtd_info *mtd, struct erase_info *instr)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct nandi_controller *nandi = chip->priv;
-
-	uint32_t block_mask = mtd->erasesize - 1;
-	loff_t offs = instr->addr;
-	size_t len = instr->len;
-	uint8_t status;
-	int ret;
-
-	dev_dbg(nandi->dev, "%s: 0x%012llx @ 0x%012llx\n", __func__,
-		(unsigned long long)len, offs);
-
-	if (offs & block_mask) {
-		dev_err(nandi->dev, "attempt to erase from non-block-aligned "
-			"offset\n");
-		return -EINVAL;
-	}
-
-	if (len & block_mask) {
-		dev_err(nandi->dev, "attempt to erase non-block-aligned "
-			"length\n");
-		return -EINVAL;
-	}
-
-	if ((offs + len) > mtd->size) {
-		dev_err(nandi->dev, "attempt to erase past end of device\n");
-		return -EINVAL;
-	}
-
-	nand_get_device(chip, mtd, FL_ERASING);
-	instr->fail_addr = MTD_FAIL_ADDR_UNKNOWN;
-
-	if (flex_check_wp(nandi)) {
-		dev_dbg(nandi->dev, "device is write-protected\n");
-		instr->state = MTD_ERASE_FAILED;
-		goto erase_exit;
-	}
-
-	instr->state = MTD_ERASING;
-	while (len) {
-		if (!nand_erasebb && mtd_block_isbad(mtd, offs)) {
-			dev_err(nandi->dev, "attempt to erase a bad block "
-				"at 0x%012llx\n", offs);
-			instr->state = MTD_ERASE_FAILED;
-			instr->fail_addr = offs;
-			goto erase_exit;
-		}
-
-		status = bch_erase_block(nandi, offs);
-
-		if (status & NAND_STATUS_FAIL) {
-			dev_err(nandi->dev, "failed to erase block at "
-				"0x%012llx\n", offs);
-			instr->state = MTD_ERASE_FAILED;
-			instr->fail_addr = offs;
-			goto erase_exit;
-		}
-
-		len -= mtd->erasesize;
-		offs += mtd->erasesize;
-	}
-	instr->state = MTD_ERASE_DONE;
-
- erase_exit:
-	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
-
-	nand_release_device(mtd);
-
-	if (ret == 0)
-		mtd_erase_callback(instr);
-
-	return ret;
-}
-
-static void nandi_dump_bad_blocks(struct nandi_controller *nandi,
-				  uint8_t *bbt)
-{
-	uint32_t block;
-	int bad_count = 0;
-	uint8_t mark;
-
-	for (block = 0; block < nandi->blocks_per_device; block++) {
-		mark = bbt_get_block_mark(bbt, block);
-		if (mark != BBT_MARK_GOOD) {
-			pr_info("\t\tBlock 0x%08x [%05u] marked bad [%s]\n",
-				block << nandi->block_shift, block,
-				(mark == BBT_MARK_BAD_FACTORY) ?
-				"Factory" : "Wear");
-			bad_count++;
-		}
-	}
-	if (bad_count == 0)
-		pr_info("\t\tNo bad blocks listed in BBT\n");
-}
-
-#ifdef CONFIG_STM_NAND_BCH_DEBUG
-/*
- * Debug code (adds considerable bloat, so enable only when necessary)
- */
-static char *nand_cmd_strs[256] = {
-	[NAND_CMD_READ0]	= "READ0",
-	[NAND_CMD_READ1]	= "READ1",
-	[NAND_CMD_RNDOUT]	= "RNDOUT",
-	[NAND_CMD_PAGEPROG]	= "PAGEPROG",
-	[NAND_CMD_READOOB]	= "READOOB",
-	[NAND_CMD_ERASE1]	= "ERASE1",
-	[NAND_CMD_ERASE2]	= "ERASE2",
-	[NAND_CMD_STATUS]	= "STATUS",
-	[NAND_CMD_STATUS_MULTI]	= "STATUS_MULTI",
-	[NAND_CMD_SEQIN]	= "SEQIN",
-	[NAND_CMD_RNDIN]	= "RNDIN",
-	[NAND_CMD_PARAM]	= "PARAM",
-	[NAND_CMD_RESET]	= "RESET",
-	[NAND_CMD_SETFEATURES]	= "SETFEATURES",
-	[NAND_CMD_GETFEATURES]	= "GETFEATURES",
-	[NAND_CMD_READSTART]	= "READSTART",
-	[NAND_CMD_RNDOUTSTART]	= "RNDOUTSTART",
-	[NAND_CMD_CACHEDPROG]	= "CACHEDPROG",
-};
-
-int bch_print_instr(char *str, uint8_t instr)
-{
-	uint8_t opc = instr & 0xf;
-	uint8_t opa = (instr >> 4) & 0xf;
-
-	switch (opc) {
-	case BCH_OPC_CMD:
-		if (opa == 0)
-			return sprintf(str, "CMD_ADDR");
-		else if (opa < 4)
-			return sprintf(str, "CL_CMD_%d", opa);
-		else if (opa < 8)
-			return sprintf(str, "CL_EX_%d", opa - 4);
-		break;
-	case BCH_OPC_INC:
-		return sprintf(str, "INC_%02d", opa);
-		break;
-	case BCH_OPC_DEC_JUMP:
-		return sprintf(str, "DEC_JUMP_%02d", opa);
-		break;
-	case BCH_OPC_DATA:
-		if (opa < 6)
-			return sprintf(str, "DATA_%d_SECTOR", 0x1 << opa);
-		break;
-	case BCH_OPC_DELAY:
-		if (opa < 2)
-			return sprintf(str, "DELAY_%d", opa);
-		break;
-	case BCH_OPC_CHECK:
-		if (opa == 0)
-			return sprintf(str, "OP_ERR");
-		else if (opa == 1)
-			return sprintf(str, "CACHE_ERR");
-		else if (opa == 2)
-			return sprintf(str, "ERROR");
-		break;
-	case BCH_OPC_ADDR:
-		if (opa < 4)
-			return sprintf(str, "AL_EX_%d", opa);
-		else
-			return sprintf(str, "AL_AD_%d", opa - 4);
-		break;
-	case BCH_OPC_NEXT_CHIP_ON:
-		if (opa == 0)
-			return sprintf(str, "NEXT_CHIP_ON");
-		break;
-	case BCH_OPC_DEC_JMP_MCS:
-		return sprintf(str, "DEC_JMP_MCS_%02d", opa);
-		break;
-	case BCH_OPC_ECC_SCORE:
-		if (opa < 8)
-			return sprintf(str, "ECC_SCORE_%d", opa);
-		break;
-	case BCH_OPC_STOP:
-		if (opa == 0)
-			return sprintf(str, "STOP");
-		break;
-	}
-
-	return sprintf(str, "INVALID");
-}
-
-static char *bch_ecc_strs[] = {
-	[BCH_18BIT_ECC] = "18-bit ECC ",
-	[BCH_30BIT_ECC] = "30-bit ECC ",
-	[BCH_NO_ECC]	= "No ECC ",
-	[BCH_ECC_RSRV]	= "RSRV "
-};
-
-static void nandi_dump_bch_prog(struct nandi_controller *nandi,
-				char *name, struct bch_prog *prog)
-{
-	char instr_str[32];
-	int i;
-
-	pr_info("BCH PROG %s:\n", name);
-	for (i = 0; i < 3; i++)
-		pr_info("\tmult_cs_addr[%d] = 0x%08x\n", i+1,
-			prog->multi_cs_addr[i]);
-	pr_info("\tmuli_cs_config  = 0x%08x [rep = %d, num = %d, "
-		"start = %d, %s]\n",
-		prog->multi_cs_config,
-		prog->multi_cs_config & 0x3,
-		(prog->multi_cs_config >> 8) & 0x3,
-		(prog->multi_cs_config >> 10) & 0x3,
-		(prog->multi_cs_config >> 12) & 0x1 ?
-		"NO_WAIT_RBN" : "WAIT_RBN");
-	for (i = 0; i < 16; i++) {
-		bch_print_instr(instr_str, prog->seq[i]);
-		pr_info("\tseq[%02d]         = 0x%02x [%s]\n",
-			i, prog->seq[i], instr_str);
-		if (prog->seq[i] == BCH_STOP)
-			break;
-	}
-	pr_info("\taddr            = 0x%08x\n", prog->addr);
-	pr_info("\textra           = 0x%08x\n", prog->extra);
-	for (i = 0; i < 4; i++)
-		pr_info("\tcmd[%02d]         = 0x%02x [%s]\n", i,
-			prog->cmd[i],
-			nand_cmd_strs[prog->cmd[i]] ?
-			nand_cmd_strs[prog->cmd[i]] : "UNKNOWN");
-
-	pr_info("\tgen_cfg         = 0x%08x [%s%s%s%s,%s]\n",
-		prog->gen_cfg,
-		(prog->gen_cfg >> 16) & 0x1 ? "x8, " : "x16, ",
-		(prog->gen_cfg >> 18) & 0x1 ? "+AL, " : "",
-		(prog->gen_cfg >> 19) & 0x1 ? "2x8, " : "",
-		bch_ecc_strs[(prog->gen_cfg >> GEN_CFG_ECC_SHIFT) & 0x3],
-		(prog->gen_cfg >> 22) & 0x1 ? "LAST_SEQ" : "");
-	pr_info("\tdelay           = 0x%08x [DELAY_0 = %d, "
-		"DELAY_1 = %d]\n",
-		prog->delay,
-		prog->delay & 0xffff, (prog->delay >> 16) & 0xffff);
-	pr_info("\tseq_cfg         = 0x%08x [RPT = %d, ID = %d, "
-		"%s%s%s]\n",
-		prog->seq_cfg,
-		prog->seq_cfg & 0xffff,
-		(prog->seq_cfg >> 16) & 0xff,
-		(prog->seq_cfg >> 24) & 0x1 ? "WRITE, " : "READ, ",
-		(prog->seq_cfg >> 25) & 0x1 ? "ERASE, " : "",
-		(prog->seq_cfg >> 26) & 0x1 ? "GO" : "STOP");
-	pr_info("\n");
-}
-
-static void nandi_dump_bch_progs(struct nandi_controller *nandi)
-{
-	nandi_dump_bch_prog(nandi, "Read Page", &bch_prog_read_page);
-	nandi_dump_bch_prog(nandi, "Write Page", &bch_prog_write_page);
-	nandi_dump_bch_prog(nandi, "Erase Block", &bch_prog_erase_block);
-}
-
-static void nandi_dump_device(struct nandi_controller *nandi,
-			      struct mtd_info *mtd, struct nand_chip *chip)
-{
-	pr_info("Device Parameters:\n");
-	pr_info("\t%-20s: 0x%08x [%u]\n", "Page Size",
-		mtd->writesize, mtd->writesize);
-	pr_info("\t%-20s: 0x%08x [%u]\n", "OOB Size",
-		mtd->oobsize, mtd->oobsize);
-	pr_info("\t%-20s: 0x%08x [%u]\n", "Block Size",
-		mtd->erasesize, mtd->erasesize);
-	pr_info("\t%-20s: 0x%012llx [%uMiB]\n", "Chip Size",
-		chip->chipsize, (unsigned int)(chip->chipsize >> 20));
-	pr_info("\t%-20s: %u\n", "Planes per Chip",
-		chip->planes_per_chip);
-	pr_info("\t%-20s: %u\n", "LUNs per Chip",
-		chip->luns_per_chip);
-	pr_info("\t%-20s: %u\n", "Num Chips", chip->numchips);
-	pr_info("\t%-20s: 0x%012llx [%uMiB]\n", "Device Size",
-		mtd->size, (unsigned int)(mtd->size >> 20));
-	pr_info("\t%-20s: 0x%08x (%s)\n", "Chip Options",
-		chip->options & NAND_CHIPOPTIONS_MSK,
-		chip->options & NAND_BUSWIDTH_16 ? "x16" : "x8");
-	pr_info("\t%-20s: 0x%08x\n", "BBM Scheme", chip->bbm);
-	pr_info("\t%-20s: %u (bits per cell = %d)\n", "cellinfo",
-		chip->cellinfo,
-		((chip->cellinfo >> 2) & 0x3) + 1);
-	pr_info("\n");
-}
-
-static void nandi_dump_bbt_info(struct nandi_controller *nandi,
-				struct nandi_bbt_info *bbt_info)
-{
-	pr_info("BBT Info:\n");
-	pr_info("\t%-20s: 0x%08x [%u]\n", "BBT Size",
-		bbt_info->bbt_size, bbt_info->bbt_size);
-	pr_info("\t%-20s: V%u at block %u\n", "Primary",
-		bbt_info->bbt_vers[0], bbt_info->bbt_block[0]);
-	pr_info("\t%-20s: V%u at block %u\n", "Mirror",
-		bbt_info->bbt_vers[1], bbt_info->bbt_block[1]);
-	pr_info("BBT:\n");
-	nandi_dump_bad_blocks(nandi, bbt_info->bbt);
-	pr_info("\n");
-}
-
-static void nandi_dump_info(struct nandi_controller *nandi)
-{
-	pr_info("\n");
-	pr_info("--------------------------------------------------"
-		"----------------------------\n");
-	pr_info("%s Debug Info\n", NAME);
-	pr_info("--------------------------------------------------"
-		"----------------------------\n");
-	nandi_dump_device(nandi, &nandi->info.mtd, &nandi->info.chip);
-	nandi_dump_bbt_info(nandi, &nandi->info.bbt_info);
-	pr_info("Controller data:\n");
-	pr_info("\t%-20s: %u\n", "Page Shift", nandi->page_shift);
-	pr_info("\t%-20s: %u\n", "Block Shift", nandi->block_shift);
-	pr_info("\t%-20s: %u\n", "Blocks per device",
-		nandi->blocks_per_device);
-	pr_info("\t%-20s: %u\n", "Sectors per Page",
-		nandi->sectors_per_page);
-	pr_info("\t%-20s: %s\n", "BCH ECC mode",
-		bch_ecc_strs[nandi->bch_ecc_mode]);
-	pr_info("\n");
-	nandi_dump_bch_progs(nandi);
-	pr_info("--------------------------------------------------"
-		"----------------------------\n\n");
-}
-#else
-static void nandi_dump_info(struct nandi_controller *nandi)
-{
-	pr_info("%s BBT:\n", NAME);
-	nandi_dump_bad_blocks(nandi, nandi->info.bbt_info.bbt);
-}
-
-#endif /* CONFIG_STM_NAND_BCH_DEBUG */
-
-
-/*
- * Initialisation
- */
-static int bch_check_compatibility(struct nandi_controller *nandi,
-				   struct mtd_info *mtd,
-				   struct nand_chip *chip)
-{
-	int bits_per_cell = ((chip->cellinfo >> 2) & 0x3) + 1;
-
-	if (bits_per_cell > 1)
-		dev_warn(nandi->dev, "MLC NAND not fully supported\n");
-
-	if (chip->options & NAND_BUSWIDTH_16) {
-		dev_err(nandi->dev, "x16 NAND not supported\n");
-		return 1;
-	}
-
-	if (nandi->blocks_per_device/4 > mtd->writesize) {
-		/* Need to implement multi-page BBT support... */
-		dev_err(nandi->dev, "BBT too big to fit in single page\n");
-		return 1;
-	}
-
-	if (bch_ecc_sizes[nandi->bch_ecc_mode] * nandi->sectors_per_page >
-	    mtd->oobsize) {
-		dev_err(nandi->dev, "insufficient OOB for selected ECC\n");
-		return 1;
-	}
-
-	return 0;
-}
-
-/* Select strongest ECC scheme compatible with OOB size */
-static int bch_set_ecc_auto(struct nandi_controller *nandi,
-			    struct mtd_info *mtd,
-			    struct nand_chip *chip)
-{
-	int try_ecc_modes[] = {BCH_30BIT_ECC, BCH_18BIT_ECC, -1};
-	int m, ecc_mode;
-	int oob_bytes_per_sector = mtd->oobsize / nandi->sectors_per_page;
-
-	for (m = 0; try_ecc_modes[m] >= 0; m++) {
-		ecc_mode = try_ecc_modes[m];
-		if (oob_bytes_per_sector >= bch_ecc_sizes[ecc_mode]) {
-			nandi->bch_ecc_mode = ecc_mode;
-			return 0;
-		}
-	}
-
-	return 1;
-}
-
-/* Configure MTD/NAND interface */
-static void nandi_set_mtd_defaults(struct nandi_controller *nandi,
-				   struct mtd_info *mtd, struct nand_chip *chip)
-{
-	struct nandi_info *info = &nandi->info;
-	int i;
-
-	/* ecclayout */
-	info->ecclayout.eccbytes = mtd->oobsize;
-	for (i = 0; i < 64; i++)
-		info->ecclayout.eccpos[i] = i;
-	info->ecclayout.oobfree[0].offset = 0;
-	info->ecclayout.oobfree[0].length = 0;
-	info->ecclayout.oobavail = 0;
-
-	/* nand_chip */
-	chip->controller = &chip->hwcontrol;
-	spin_lock_init(&chip->controller->lock);
-	init_waitqueue_head(&chip->controller->wq);
-	chip->priv = nandi;
-	chip->ecc.layout = &info->ecclayout;
-
-	chip->cmdfunc = flex_command_lp;
-	chip->read_byte = flex_read_byte;
-	chip->select_chip = flex_select_chip;
-	chip->waitfunc = flex_wait_func;
-	chip->read_buf = flex_read_buf;
-	chip->write_buf = flex_write_buf;
-
-	chip->read_word = flex_read_word_BUG;
-	chip->block_bad = flex_block_bad_BUG; /**/
-	chip->block_markbad = flex_block_markbad_BUG; /**/
-	chip->verify_buf = flex_verify_buf_BUG; /**/
-	chip->scan_bbt = flex_scan_bbt_BUG; /**/
-
-	/* mtd_info */
-	mtd->owner = THIS_MODULE;
-	mtd->type = MTD_NANDFLASH;
-	mtd->flags = MTD_CAP_NANDFLASH;
-	mtd->ecclayout = &info->ecclayout;
-	mtd->oobavail = 0;
-
-	mtd->read = mtd_read;
-	mtd->write = mtd_write;
-	mtd->erase = mtd_erase;
-	mtd->read_oob = mtd_read_oob;
-	mtd->write_oob = mtd_write_oob;
-	mtd->block_isbad = mtd_block_isbad;
-	mtd->block_markbad = mtd_block_markbad;
-
-	mtd->point = NULL;
-	mtd->unpoint = NULL;
-	mtd->lock = NULL;
-	mtd->unlock = NULL;
-
-	mtd->sync = nand_sync;
-	mtd->suspend = nand_suspend;
-	mtd->resume = nand_resume;
-}
-
-static void nandi_init_hamming(struct nandi_controller *nandi, int emi_bank)
-{
-	dev_dbg(nandi->dev, "%s\n", __func__);
-
-	emiss_nandi_select(STM_NANDI_HAMMING);
-
-	/* Reset and disable boot-mode controller */
-	writel(BOOT_CFG_RESET, nandi->base + NANDHAM_BOOTBANK_CFG);
-	udelay(1);
-	writel(0x00000000, nandi->base + NANDHAM_BOOTBANK_CFG);
-
-	/* Reset controller */
-	writel(CFG_RESET, nandi->base + NANDHAM_FLEXMODE_CFG);
-	udelay(1);
-	writel(0x00000000, nandi->base + NANDHAM_FLEXMODE_CFG);
-
-	/* Set EMI Bank */
-	writel(0x1 << emi_bank, nandi->base + NANDHAM_FLEX_MUXCTRL);
-
-	/* Enable FLEX mode */
-	writel(CFG_ENABLE_FLEX, nandi->base + NANDHAM_FLEXMODE_CFG);
-
-	/* Configure FLEX_DATA_READ/WRITE for 1-byte access */
-	writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-	writel(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-	       nandi->base + NANDHAM_FLEX_DATAREAD_CONFIG);
-
-	/* RBn interrupt on rising edge */
-	writel(NAND_EDGE_CFG_RBN_RISING, nandi->base + NANDHAM_INT_EDGE_CFG);
-
-	/* Enable interrupts */
-	nandi_enable_interrupts(nandi, NAND_INT_ENABLE);
-}
-
-static void nandi_init_bch(struct nandi_controller *nandi, int emi_bank)
-{
-	dev_dbg(nandi->dev, "%s\n", __func__);
-
-	/* Initialise BCH Controller */
-	emiss_nandi_select(STM_NANDI_BCH);
-
-	/* Reset and disable boot-mode controller */
-	writel(BOOT_CFG_RESET, nandi->base + NANDBCH_BOOTBANK_CFG);
-	udelay(1);
-	writel(0x00000000, nandi->base + NANDBCH_BOOTBANK_CFG);
-
-	/* Reset AFM controller */
-	writel(CFG_RESET, nandi->base + NANDBCH_CONTROLLER_CFG);
-	udelay(1);
-	writel(0x00000000, nandi->base + NANDBCH_CONTROLLER_CFG);
-
-	/* Set EMI Bank */
-	writel(0x1 << emi_bank, nandi->base + NANDBCH_FLEX_MUXCTRL);
-
-	/* Reset ECC stats */
-	writel(0x7f0, nandi->base + NANDBCH_CONTROLLER_CFG);
-	udelay(1);
-
-	/* Enable AFM */
-	writel(CFG_ENABLE_AFM, nandi->base + NANDBCH_CONTROLLER_CFG);
-
-	/* Timing parameters */
-	/* Values from validation found not to work on some parts.  Awaiting
-	 * clarification.  Use reset values for the time being.
-	 *
-	 * writel(0x14000205, nandi->base + NANDBCH_CTL_TIMING);
-	 * writel(0x00020304, nandi->base + NANDBCH_WEN_TIMING);
-	 * writel(0x060b0304, nandi->base + NANDBCH_REN_TIMING);
-	 */
-
-	/* Configure Read DMA Plugs (values supplied by Validation)*/
-	writel(0x00000005, nandi->dma + EMISS_NAND_RD_DMA_PAGE_SIZE);
-	writel(0x00000005, nandi->dma + EMISS_NAND_RD_DMA_MAX_OPCODE_SIZE);
-	writel(0x00000002, nandi->dma + EMISS_NAND_RD_DMA_MIN_OPCODE_SIZE);
-	writel(0x00000001, nandi->dma + EMISS_NAND_RD_DMA_MAX_CHUNK_SIZE);
-	writel(0x00000000, nandi->dma + EMISS_NAND_RD_DMA_MAX_MESSAGE_SIZE);
-
-	/* Configure Write DMA Plugs (values supplied by Validation) */
-	writel(0x00000005, nandi->dma + EMISS_NAND_WR_DMA_PAGE_SIZE);
-	writel(0x00000005, nandi->dma + EMISS_NAND_WR_DMA_MAX_OPCODE_SIZE);
-	writel(0x00000002, nandi->dma + EMISS_NAND_WR_DMA_MIN_OPCODE_SIZE);
-	writel(0x00000001, nandi->dma + EMISS_NAND_WR_DMA_MAX_CHUNK_SIZE);
-	writel(0x00000000, nandi->dma + EMISS_NAND_WR_DMA_MAX_MESSAGE_SIZE);
-
-	nandi_enable_interrupts(nandi, NAND_INT_ENABLE);
-}
-
-static int __devinit remap_named_resource(struct platform_device *pdev,
-					  char *name,
-					  void __iomem **io_ptr)
-{
-	struct resource *res;
-	resource_size_t size;
-	void __iomem *p;
-
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, name);
-	if (!res)
-		return -ENXIO;
-
-	size = resource_size(res);
-
-	if (!devm_request_mem_region(&pdev->dev,
-				     res->start, size, name))
-		return -EBUSY;
-
-	p = devm_ioremap_nocache(&pdev->dev, res->start, size);
-	if (!p)
-		return -ENOMEM;
-
-	*io_ptr = p;
-
-	return 0;
-}
-
-static struct nandi_controller * __init
-nandi_init_resources(struct platform_device *pdev)
-{
-	struct nandi_controller *nandi;
-	int irq;
-
-	int err = 0;
-
-	nandi = devm_kzalloc(&pdev->dev, sizeof(struct nandi_controller),
-			     GFP_KERNEL);
-	if (!nandi) {
-		dev_err(&pdev->dev, "failed to allocate NANDi controller "
-			"data\n");
-		return ERR_PTR(-ENOMEM);
-	}
-
-	nandi->dev = &pdev->dev;
-
-	err = remap_named_resource(pdev, "nand_mem", &nandi->base);
-	if (err)
-		return ERR_PTR(err);
-
-	err = remap_named_resource(pdev, "nand_dma", &nandi->dma);
-	if (err)
-		return ERR_PTR(err);
-
-	irq = platform_get_irq_byname(pdev, "nand_irq");
-	if (irq < 0) {
-		dev_err(&pdev->dev, "failed to find IRQ resource\n");
-		return ERR_PTR(irq);
-	}
-
-	err = devm_request_irq(&pdev->dev, irq, nandi_irq_handler,
-			       IRQF_DISABLED, dev_name(&pdev->dev), nandi);
-	if (err) {
-		dev_err(&pdev->dev, "irq request failed\n");
-		return ERR_PTR(err);
-	}
-
-	platform_set_drvdata(pdev, nandi);
-
-	return nandi;
-}
-
-static void __devexit nandi_exit_controller(struct nandi_controller *nandi)
-{
-
-}
-
-static void __devinit nandi_init_controller(struct nandi_controller *nandi,
-					    int emi_bank)
-{
-	nandi_init_bch(nandi, emi_bank);
-	nandi_init_hamming(nandi, emi_bank);
-}
-
-
-static int __devinit stm_nand_bch_probe(struct platform_device *pdev)
-{
-	struct stm_plat_nand_bch_data *pdata = pdev->dev.platform_data;
-	struct stm_nand_bank_data *bank;
-
-	struct nandi_controller *nandi;
-	struct nandi_info *info;
-	struct nandi_bbt_info *bbt_info;
-	struct mtd_info *mtd;
-	struct nand_chip *chip;
-	uint32_t buf_size;
-	uint32_t bbt_buf_size;
-	int i;
-	int err;
-
-	nandi = nandi_init_resources(pdev);
-	if (IS_ERR(nandi)) {
-		dev_err(&pdev->dev, "failed to initialise NANDi resources\n");
-		return PTR_ERR(nandi);
-	}
-
-	init_completion(&nandi->seq_completed);
-	init_completion(&nandi->rbn_completed);
-
-	bank = pdata->bank;
-	nandi_init_controller(nandi, bank->csn);
-
-	info = &nandi->info;
-	chip = &info->chip;
-	bbt_info = &info->bbt_info;
-	mtd = &info->mtd;
-	mtd->priv = chip;
-	mtd->name = dev_name(&pdev->dev);
-
-	nandi_set_mtd_defaults(nandi, mtd, chip);
-
-	if (nand_scan_ident(mtd, 1) != 0)
-		return -ENODEV;
-
-	/* Derive some working variables */
-	nandi->sectors_per_page = mtd->writesize / NANDI_BCH_SECTOR_SIZE;
-	nandi->blocks_per_device = mtd->size >> chip->phys_erase_shift;
-	nandi->page_shift = chip->page_shift;
-	nandi->block_shift = chip->phys_erase_shift;
-
-	/* Set ECC mode */
-	switch (pdata->bch_ecc_cfg) {
-	case BCH_ECC_CFG_AUTO:
-		if (bch_set_ecc_auto(nandi, mtd, chip) != 0) {
-			dev_err(nandi->dev, "insufficient OOB for BCH ECC\n");
-			return -EINVAL;
-		}
-		break;
-	case BCH_ECC_CFG_NOECC:
-		nandi->bch_ecc_mode = BCH_NO_ECC;
-		break;
-	case BCH_ECC_CFG_18BIT:
-		nandi->bch_ecc_mode = BCH_18BIT_ECC;
-		break;
-	case BCH_ECC_CFG_30BIT:
-		nandi->bch_ecc_mode = BCH_30BIT_ECC;
-		break;
-	}
-
-	/* Check compatibility */
-	if (bch_check_compatibility(nandi, mtd, chip) != 0) {
-		dev_err(nandi->dev, "NAND device incompatible with NANDi/BCH "
-			"Controller\n");
-		return -EINVAL;
-	}
-
-	/* Tune BCH programs according to device found and ECC mode */
-	bch_configure_progs(nandi);
-
-	/*
-	 * Initialise working buffers, accomodating DMA alignment constraints:
-	 */
-
-	/*	- Page and OOB */
-	buf_size = mtd->writesize + mtd->oobsize + NANDI_BCH_DMA_ALIGNMENT;
-
-	/*	- BBT data (page-size aligned) */
-	bbt_info->bbt_size = nandi->blocks_per_device >> 2; /* 2 bits/block */
-	bbt_buf_size = ALIGN(bbt_info->bbt_size, mtd->writesize);
-	buf_size += bbt_buf_size + NANDI_BCH_DMA_ALIGNMENT;
-
-	/*	- BCH BUF list */
-	buf_size += NANDI_BCH_BUF_LIST_SIZE + NANDI_BCH_DMA_ALIGNMENT;
-
-	/* Allocate bufffer */
-	nandi->buf = devm_kzalloc(&pdev->dev, buf_size, GFP_KERNEL);
-	if (!nandi->buf) {
-		dev_err(nandi->dev, "failed to allocate working buffers\n");
-		return -ENOMEM;
-	}
-
-	/* Set/Align buffer pointers */
-	nandi->page_buf = PTR_ALIGN(nandi->buf, NANDI_BCH_DMA_ALIGNMENT);
-	nandi->oob_buf = nandi->page_buf + mtd->writesize;
-	bbt_info->bbt = PTR_ALIGN(nandi->oob_buf + mtd->oobsize,
-				  NANDI_BCH_DMA_ALIGNMENT);
-	nandi->buf_list = (uint32_t *) PTR_ALIGN(bbt_info->bbt + bbt_buf_size,
-						 NANDI_BCH_DMA_ALIGNMENT);
-	nandi->cached_page = -1;
-
-	/* Load Flash-resident BBT */
-	err = bch_load_bbt(nandi, bbt_info);
-
-	if (err) {
-		dev_err(nandi->dev, "failed to find BBTs: "
-			"scan device for bad-block markers\n");
-		/* scan, build, and write BBT */
-		nandi_scan_build_bbt(nandi, bbt_info, chip->bbm);
-		if (bch_update_bbts(nandi, bbt_info, NAND_IBBT_UPDATE_BOTH,
-				    bbt_info->bbt_vers[0] + 1) != 0)
-			return -ENXIO;
-	}
-
-	nandi_dump_info(nandi);
-
-	/* Add partitions */
-	if (mtd_has_partitions()) {
-		if (mtd_has_cmdlinepart()) {
-			static const char *part_probes[]
-				= { "cmdlinepart", NULL, };
-			info->nr_parts = parse_mtd_partitions(mtd,
-							      part_probes,
-							      &info->parts,
-							      0);
-		}
-
-		if (info->nr_parts <= 0 && bank->partitions) {
-			info->parts = bank->partitions;
-			info->nr_parts = bank->nr_partitions;
-		}
-
-		if (info->nr_parts > 0) {
-			for (i = 0; i < info->nr_parts; i++) {
-				dev_dbg(nandi->dev, "partitions[%d] = "
-					"{.name = %s, .offset = 0x%llx, "
-					".size = 0x%llx (%lldKiB) }\n",
-					i, info->parts[i].name,
-					(long long)info->parts[i].offset,
-					(long long)info->parts[i].size,
-					(long long)(info->parts[i].size >> 10));
-			}
-
-			if (add_mtd_partitions(mtd, info->parts,
-					       info->nr_parts)) {
-				return -ENODEV;
-			}
-
-			return 0;
-		}
-
-	} else if (bank->nr_partitions) {
-		dev_info(nandi->dev, " ignoring %d default partitions on %s\n",
-			 bank->nr_partitions, "NAND");
-	}
-
-	if (add_mtd_device(mtd))
-		return -ENODEV;
-
-	return 0;
-}
-
-static int __devexit stm_nand_bch_remove(struct platform_device *pdev)
-{
-	struct stm_plat_nand_bch_data *pdata = pdev->dev.platform_data;
-	struct stm_nand_bank_data *bank = pdata->bank;
-	struct nandi_controller *nandi = platform_get_drvdata(pdev);
-	struct nandi_info *info = &nandi->info;
-
-	if (mtd_has_partitions() && info->parts) {
-		del_mtd_partitions(&info->mtd);
-		if (info->parts != bank->partitions)
-			kfree(info->parts);
-	} else {
-		del_mtd_device(&info->mtd);
-	}
-
-	nandi_exit_controller(nandi);
-
-	return 0;
-}
-
-static struct platform_driver stm_nand_bch_driver = {
-	.probe		= stm_nand_bch_probe,
-	.remove		= stm_nand_bch_remove,
-	.driver		= {
-		.name	= NAME,
-		.owner	= THIS_MODULE,
-	},
-};
-
-static int __init stm_nand_bch_init(void)
-{
-	return platform_driver_register(&stm_nand_bch_driver);
-}
-
-static void __exit stm_nand_bch_exit(void)
-{
-	platform_driver_unregister(&stm_nand_bch_driver);
-}
-
-module_init(stm_nand_bch_init);
-module_exit(stm_nand_bch_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Angus Clark");
-MODULE_DESCRIPTION("STM NAND BCH driver");
--- a/drivers/mtd/nand/stm_nandc_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/mtd/nand/stm_nandc_regs.h	2012-11-11 01:39:29.000000000 +0100
@@ -0,0 +1,107 @@
+/*
+ *   STMicroelectronics NAND Controller
+ *
+ *   See ADCS #7864584: "NAND Flash support upgrades for FMI Functional
+ *   Secification".
+ *
+ *   Copyright (c) 2008 STMicroelectronics Limited
+ *   Author: Angus Clark <angus.clark@st.com>
+ *
+ *   May be copied or modified under the terms of the GNU General Public
+ *   License.  See linux/COPYING for more information.
+ *
+ */
+
+#ifndef STM_NANDC_REGS_H
+#define STM_NANDC_REGS_H
+
+#define EMINAND_CONFIG_SIZE			0x1000
+
+/* Register Addresses (OFFSET from EMINAND_CONFIG_BASE) */
+#define EMINAND_BOOTBANK_CONFIG			0x000
+#define EMINAND_RBN_STATUS			0x004
+#define EMINAND_INTERRUPT_ENABLE		0x010
+#define EMINAND_INTERRUPT_STATUS		0x014
+#define EMINAND_INTERRUPT_CLEAR			0x018
+#define EMINAND_INTERRUPT_EDGECONFIG		0x01C
+#define EMINAND_CONTROL_TIMING			0x040
+#define EMINAND_WEN_TIMING			0x044
+#define EMINAND_REN_TIMING			0x048
+#define EMINAND_FLEXMODE_CONFIG			0x100
+#define EMINAND_MUXCONTROL_REG			0x104
+#define EMINAND_CSN_ALTERNATE			0x108
+#define EMINAND_FLEX_DATAWRITE_CONFIG		0x10C
+#define EMINAND_FLEX_DATAREAD_CONFIG		0x110
+#define EMINAND_FLEX_COMMAND_REG		0x114
+#define EMINAND_FLEX_ADDRESS_REG		0x118
+#define EMINAND_FLEX_DATA			0x120
+#define EMINAND_VERSION_REG			0x144
+#define EMINAND_MULTI_CS_CONFIG_REG		0x1EC
+
+
+/* Advanced Flex Mode registers (OFFSET from EMINAND_CONFIG_BASE) */
+#define EMINAND_AFM_SEQUENCE_REG_1		0x200
+#define EMINAND_AFM_SEQUENCE_REG_2		0x204
+#define EMINAND_AFM_SEQUENCE_REG_3		0x208
+#define EMINAND_AFM_SEQUENCE_REG_4		0x20C
+#define EMINAND_AFM_ADDRESS_REG			0x210
+#define EMINAND_AFM_EXTRA_REG			0x214
+#define EMINAND_AFM_COMMAND_REG			0x218
+#define EMINAND_AFM_SEQUENCE_CONFIG_REG		0x21C
+#define EMINAND_AFM_GENERIC_CONFIG_REG		0x220
+#define EMINAND_AFM_SEQUENCE_STATUS_REG		0x240
+#define EMINAND_AFM_ECC_CHECKCODE_REG_0		0x280
+#define EMINAND_AFM_ECC_CHECKCODE_REG_1		0x284
+#define EMINAND_AFM_ECC_CHECKCODE_REG_2		0x288
+#define EMINAND_AFM_ECC_CHECKCODE_REG_3		0x28C
+#define EMINAND_AFM_DATA_FIFO			0x300
+
+/* AFM Commands */
+#define AFM_STOP				0x0
+#define AFM_CMD					0x1
+#define AFM_INC					0x2
+#define AFM_DEC_JUMP				0x3
+#define AFM_DATA				0x4
+#define AFM_SPARE				0x5
+#define AFM_CHECK				0x6
+#define AFM_ADDR				0x7
+#define AFM_WRBN				0xA
+
+/* FLEX: Address Register Fields */
+#define FLX_ADDR_REG_RBN			(0x1 << 27)
+#define FLX_ADDR_REG_BEAT_1			(0x1 << 28)
+#define FLX_ADDR_REG_BEAT_2			(0x2 << 28)
+#define FLX_ADDR_REG_BEAT_3			(0x3 << 28)
+#define FLX_ADDR_REG_BEAT_4			(0x0 << 28)
+#define FLX_ADDR_REG_ADD8_VALID			(0x1 << 30)
+#define FLX_ADDR_REG_CSN_STATUS			(0x1 << 31)
+
+/* FLEX: Commad Register fields */
+#define FLX_CMD_REG_RBN				(0x1 << 27)
+#define FLX_CMD_REG_BEAT_1			(0x1 << 28)
+#define FLX_CMD_REG_BEAT_2			(0x2 << 28)
+#define FLX_CMD_REG_BEAT_3			(0x3 << 28)
+#define FLX_CMD_REG_BEAT_4			(0x0 << 28)
+#define FLX_CMD_REG_CSN_STATUS			(0x1 << 31)
+#define FLX_CMD(x)				(((x) & 0xff) |		\
+						 FLX_CMD_REG_RBN |	\
+						 FLX_CMD_REG_BEAT_1 |	\
+						 FLX_CMD_REG_CSN_STATUS)
+
+/* FLEX: Data Config fields */
+#define FLX_DATA_CFG_RBN			(0x1 << 27)
+#define FLX_DATA_CFG_BEAT_1			(0x1 << 28)
+#define FLX_DATA_CFG_BEAT_2			(0x2 << 28)
+#define FLX_DATA_CFG_BEAT_3			(0x3 << 28)
+#define FLX_DATA_CFG_BEAT_4			(0x0 << 28)
+#define FLX_DATA_CFG_BYTES_1			(0x0 << 30)
+#define FLX_DATA_CFG_BYTES_2			(0x1 << 30)
+#define FLX_DATA_CFG_CSN_STATUS			(0x1 << 31)
+
+/* AFM: Sequence Config fields */
+#define AFM_SEQ_CFG_GO				(0x1 << 26)
+#define AFM_SEQ_CFG_DIR_WRITE			(0x1 << 24)
+
+
+
+#endif /* STM_NANDC_REGS_H */
--- a/drivers/mtd/nand/stm_nand_flex.c	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/stm_nand_flex.c	2012-11-11 01:39:29.000000000 +0100
@@ -61,7 +61,7 @@
 #include <linux/interrupt.h>
 #include <linux/delay.h>
 
-#include "stm_nand_regs.h"
+#include "stm_nandc_regs.h"
 
 #ifdef CONFIG_MTD_PARTITIONS
 #include <linux/mtd/partitions.h>
@@ -160,13 +160,13 @@
 
 /*** FLEX mode control functions (cf nand_base.c) ***/
 
-/* Assumes NANDHAM_DATAREAD has been configured for 1-byte reads. */
+/* Assumes EMINAND_DATAREAD has been configured for 1-byte reads. */
 static uint8_t flex_read_byte(struct mtd_info *mtd)
 {
 	struct stm_nand_flex_controller *flex = mtd_to_flex(mtd);
 	uint32_t reg;
 
-	reg =  flex_readreg(NANDHAM_FLEX_DATA);
+	reg =  flex_readreg(EMINAND_FLEX_DATA);
 
 	return (uint8_t)(reg & 0xff);
 }
@@ -182,13 +182,13 @@
 
 	if (cmd != NAND_CMD_NONE) {
 		if (flex_ctrl & NAND_CLE) {
-			reg = (cmd & 0xff) | FLEX_CMD_BEATS_1 |
-				FLEX_CMD_CSN;
-			flex_writereg(reg, NANDHAM_FLEX_CMD);
+			reg = (cmd & 0xff) | FLX_CMD_REG_BEAT_1 |
+				FLX_CMD_REG_CSN_STATUS;
+			flex_writereg(reg, EMINAND_FLEX_COMMAND_REG);
 		} else if (flex_ctrl & NAND_ALE) {
-			reg = (cmd & 0xff) | FLEX_ADDR_ADD8_VALID |
-				FLEX_ADDR_BEATS_1 | FLEX_ADDR_CSN;
-			flex_writereg(reg, NANDHAM_FLEX_ADD);
+			reg = (cmd & 0xff) | FLX_ADDR_REG_ADD8_VALID |
+				FLX_ADDR_REG_BEAT_1 | FLX_ADDR_REG_CSN_STATUS;
+			flex_writereg(reg, EMINAND_FLEX_ADDRESS_REG);
 		} else {
 			printk(KERN_ERR NAME "%s: unknown ctrl 0x%02x!\n",
 			       __FUNCTION__, flex_ctrl);
@@ -246,7 +246,7 @@
 
 	/* Apply a small delay before sampling RBn signal */
 	ndelay(100);
-	return (flex_readreg(NANDHAM_RBN_STA) & (0x4)) ? 1 : 0;
+	return (flex_readreg(EMINAND_RBN_STATUS) & (0x4)) ? 1 : 0;
 }
 
 /* FLEX mode ECC requires 4-byte read/writes.  To maintain compatibility with
@@ -276,8 +276,8 @@
 	}
 
 	/* Switch to 4-byte reads */
-	flex_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 	while (lenaligned > 0) {
 		spin_lock_irqsave(&(flex->lock), irq_flags);
@@ -304,8 +304,8 @@
 		memcpy(buf, flex->buf, len);
 
 	/* Switch back to 1-byte reads */
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 }
 #else
 static void flex_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
@@ -327,17 +327,17 @@
 	}
 
 	/* Switch to 4-byte reads (required for ECC) */
-	flex_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
-	readsl(flex->base_addr + NANDHAM_FLEX_DATA, p, lenaligned/4);
+	readsl(flex->base_addr + EMINAND_FLEX_DATA, p, lenaligned/4);
 
 	if (notaligned)
 		memcpy(buf, p, len);
 
 	/* Switch back to 1-byte reads */
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 }
 #endif
@@ -358,14 +358,14 @@
 	}
 
 	/* Switch to 4-byte reads (required for ECC) */
-	flex_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAWRITE_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAWRITE_CONFIG);
 
-	writesl(flex->base_addr + NANDHAM_FLEX_DATA, p, len/4);
+	writesl(flex->base_addr + EMINAND_FLEX_DATA, p, len/4);
 
 	/* Switch back to 1-byte writes  */
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAWRITE_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAWRITE_CONFIG);
 
 }
 
@@ -378,11 +378,11 @@
 	int i;
 
 	/* Switch to 4-byte reads */
-	flex_writereg(FLEX_DATA_CFG_BEATS_4 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_4 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 	for (i = 0; i < len/4; i++) {
-		d = readl(flex->base_addr + NANDHAM_FLEX_DATA);
+		d = readl(flex->base_addr + EMINAND_FLEX_DATA);
 		if (d != *p++) {
 			ret = -EFAULT;
 			goto out1;
@@ -391,8 +391,8 @@
 
  out1:
 	/* Switch back to 1-byte reads */
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 	return ret;
 }
@@ -818,8 +818,8 @@
 	n = (tm->WE_to_RBn + emi_t_ns - 1)/emi_t_ns;
 	reg |= (n & 0xff) << 24;
 
-	DEBUG(MTD_DEBUG_LEVEL0, "%s: CTL_TIMING = 0x%08x\n", NAME, reg);
-	flex_writereg(reg, NANDHAM_CTL_TIMING);
+	DEBUG(MTD_DEBUG_LEVEL0, "%s: CONTROL_TIMING = 0x%08x\n", NAME, reg);
+	flex_writereg(reg, EMINAND_CONTROL_TIMING);
 
 	/* WEN_TIMING */
 	n = (tm->wr_on + emi_t_ns - 1)/emi_t_ns;
@@ -829,7 +829,7 @@
 	reg |= (n & 0xff) << 8;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "%s: WEN_TIMING = 0x%08x\n", NAME, reg);
-	flex_writereg(reg, NANDHAM_WEN_TIMING);
+	flex_writereg(reg, EMINAND_WEN_TIMING);
 
 	/* REN_TIMING */
 	n = (tm->rd_on + emi_t_ns - 1)/emi_t_ns;
@@ -839,7 +839,7 @@
 	reg |= (n & 0xff) << 8;
 
 	DEBUG(MTD_DEBUG_LEVEL0, "%s: REN_TIMING = 0x%08x\n", NAME, reg);
-	flex_writereg(reg, NANDHAM_REN_TIMING);
+	flex_writereg(reg, EMINAND_REN_TIMING);
 }
 
 /* FLEX mode chip select: For now we only support 1 chip per
@@ -866,7 +866,7 @@
 
 		/* Set CSn on FLEX controller */
 		flex->current_csn = data->csn;
-		flex_writereg(0x1 << data->csn, NANDHAM_FLEX_MUXCTRL);
+		flex_writereg(0x1 << data->csn, EMINAND_MUXCONTROL_REG);
 
 		/* Set up timing parameters */
 		flex_set_timings(flex, data->timing_data);
@@ -884,31 +884,33 @@
 {
 	printk(NAME ": FLEX Registers:\n");
 	printk(KERN_INFO "\tbootbank_config = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_BOOTBANK_CFG));
+	       (unsigned int)flex_readreg(EMINAND_BOOTBANK_CONFIG));
 	printk(KERN_INFO "\trbn_status = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_RBN_STA));
+	       (unsigned int)flex_readreg(EMINAND_RBN_STATUS));
 	printk(KERN_INFO "\tinterrupt_enable = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_INT_EN));
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_ENABLE));
 	printk(KERN_INFO "\tinterrupt_status = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_INT_STA));
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_STATUS));
 	printk(KERN_INFO "\tinterrupt_clear = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_INT_CLR));
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_CLEAR));
 	printk(KERN_INFO "\tinterrupt_edgeconfig = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_INT_EDGE_CFG));
+	       (unsigned int)flex_readreg(EMINAND_INTERRUPT_EDGECONFIG));
 	printk(KERN_INFO "\tcontrol_timing = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_CTL_TIMING));
+	       (unsigned int)flex_readreg(EMINAND_CONTROL_TIMING));
 	printk(KERN_INFO "\twen_timing = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_WEN_TIMING));
+	       (unsigned int)flex_readreg(EMINAND_WEN_TIMING));
 	printk(KERN_INFO "\tren_timing = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_REN_TIMING));
+	       (unsigned int)flex_readreg(EMINAND_REN_TIMING));
 	printk(KERN_INFO "\tflexmode_config = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_FLEXMODE_CFG));
+	       (unsigned int)flex_readreg(EMINAND_FLEXMODE_CONFIG));
 	printk(KERN_INFO "\tmuxcontrol_reg = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_FLEX_MUXCTRL));
+	       (unsigned int)flex_readreg(EMINAND_MUXCONTROL_REG));
+	printk(KERN_INFO "\tcsn_alternate_reg = 0x%08x\n",
+	       (unsigned int)flex_readreg(EMINAND_CSN_ALTERNATE));
 	printk(KERN_INFO "\tmulti_cs_config_reg = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_MULTI_CS_CONFIG_REG));
+	       (unsigned int)flex_readreg(EMINAND_MULTI_CS_CONFIG_REG));
 	printk(KERN_INFO "\tversion_reg = 0x%08x\n",
-	       (unsigned int)flex_readreg(NANDHAM_VERSION_REG));
+	       (unsigned int)flex_readreg(EMINAND_VERSION_REG));
 }
 #endif /* CONFIG_MTD_DEBUG */
 
@@ -928,7 +930,7 @@
 
 	/* Request IO Memory */
 	resource = platform_get_resource_byname(pdev, IORESOURCE_MEM,
-						"nand_mem");
+						"flex_mem");
 	if (!resource) {
 		printk(KERN_ERR NAME ": Failed to get FLEX IORESOURCE_MEM.\n");
 		res = -ENODEV;
@@ -956,11 +958,11 @@
 	}
 
 #ifdef CONFIG_STM_NAND_FLEX_CACHED
-	flex->data_phys = resource->start + NANDHAM_FLEX_DATA;
+	flex->data_phys = resource->start + EMINAND_FLEX_DATA;
 	flex->data_cached = ioremap_cache(flex->data_phys, L1_CACHE_BYTES);
 	if (!flex->data_cached) {
 		printk(KERN_ERR NAME " Failed to map data reg 0x%08x\n",
-		       resource->start + NANDHAM_FLEX_DATA);
+		       resource->start + EMINAND_FLEX_DATA);
 		res = -EINVAL;
 		goto out3;
 	}
@@ -982,26 +984,26 @@
 	init_waitqueue_head(&flex->hwcontrol.wq);
 
 	/* Disable boot_not_flex */
-	flex_writereg(0x00000000, NANDHAM_BOOTBANK_CFG);
+	flex_writereg(0x00000000, EMINAND_BOOTBANK_CONFIG);
 
 	/* Reset FLEX Controller */
-	flex_writereg((0x1 << 3), NANDHAM_FLEXMODE_CFG);
+	flex_writereg((0x1 << 3), EMINAND_FLEXMODE_CONFIG);
 	udelay(1);
-	flex_writereg(0x00, NANDHAM_FLEXMODE_CFG);
+	flex_writereg(0x00, EMINAND_FLEXMODE_CONFIG);
 
 	/* Set Controller to FLEX mode */
-	flex_writereg(0x00000001, NANDHAM_FLEXMODE_CFG);
+	flex_writereg(0x00000001, EMINAND_FLEXMODE_CONFIG);
 
 	/* Not using interrupts in FLEX mode */
-	flex_writereg(0x00, NANDHAM_INT_EN);
+	flex_writereg(0x00, EMINAND_INTERRUPT_ENABLE);
 
 	/* To fit with MTD framework, configure FLEX_DATA reg for 1-byte
 	 * read/writes, and deassert CSn
 	 */
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAWRITE_CONFIG);
-	flex_writereg(FLEX_DATA_CFG_BEATS_1 | FLEX_DATA_CFG_CSN,
-		      NANDHAM_FLEX_DATAREAD_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAWRITE_CONFIG);
+	flex_writereg(FLX_DATA_CFG_BEAT_1 | FLX_DATA_CFG_CSN_STATUS,
+		      EMINAND_FLEX_DATAREAD_CONFIG);
 
 #ifdef CONFIG_MTD_DEBUG
 	flex_print_regs(flex);
@@ -1100,13 +1102,13 @@
 	data->chip.ecc.mode = NAND_ECC_SOFT;
 
 	/* Data IO */
-	data->chip.IO_ADDR_R = flex->base_addr + NANDHAM_FLEX_DATA;
-	data->chip.IO_ADDR_W = flex->base_addr + NANDHAM_FLEX_DATA;
+	data->chip.IO_ADDR_R = flex->base_addr + EMINAND_FLEX_DATA;
+	data->chip.IO_ADDR_W = flex->base_addr + EMINAND_FLEX_DATA;
 
 #if defined(CONFIG_CPU_SUBTYPE_STX7200)
 	/* Reset AFM program. Why!?! */
-	flex_readreg(NANDHAM_AFM_SEQUENCE_STATUS_REG);
-	memset(flex->base_addr + NANDHAM_AFM_SEQUENCE_REG_1, 0, 32);
+	flex_readreg(EMINAND_AFM_SEQUENCE_STATUS_REG);
+	memset(flex->base_addr + EMINAND_AFM_SEQUENCE_REG_1, 0, 32);
 #endif
 
 	/* Scan to find existance of the device */
--- a/drivers/mtd/nand/stm_nand_regs.h	2012-12-23 15:47:30.000000000 +0100
+++ b/drivers/mtd/nand/stm_nand_regs.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,333 +0,0 @@
-/*
- *   drivers/mtd/nand/stm_nandc_regs.h
- *
- *   STMicroelectronics NAND Controller register definitions
- *   Applicable to:
- *	Standalone Hamming Contoller (FLEX mode & AFM)
- *	NANDi Hamming Controller (FLEX & AFM)
- *	NANDi BCH Controller (AFM)
- *
- *   Copyright (c) 2008-2011 STMicroelectronics Limited
- *   Author: Angus Clark <angus.clark@st.com>
- *
- *   May be copied or modified under the terms of the GNU General Public
- *   License.  See linux/COPYING for more information.
- *
- */
-
-#ifndef STM_NANDC_REGS_H
-#define STM_NANDC_REGS_H
-
-/* Hamming Controller Registers (Offsets from EMINAND_BASE) */
-#define NANDHAM_BOOTBANK_CFG				0x000
-#define NANDHAM_RBN_STA					0x004
-#define NANDHAM_INT_EN					0x010
-#define NANDHAM_INT_STA					0x014
-#define NANDHAM_INT_CLR					0x018
-#define NANDHAM_INT_EDGE_CFG				0x01C
-#define NANDHAM_CTL_TIMING				0x040
-#define NANDHAM_WEN_TIMING				0x044
-#define NANDHAM_REN_TIMING				0x048
-#define NANDHAM_BLOCK_ZERO_REMAP_REG			0x04C
-#define NANDHAM_FLEXMODE_CFG				0x100
-#define NANDHAM_FLEX_MUXCTRL				0x104
-#define NANDHAM_FLEX_DATAWRITE_CONFIG			0x10C
-#define NANDHAM_FLEX_DATAREAD_CONFIG			0x110
-#define NANDHAM_FLEX_CMD				0x114
-#define NANDHAM_FLEX_ADD				0x118
-#define NANDHAM_FLEX_DATA				0x120
-#define NANDHAM_VERSION_REG				0x144
-#define NANDHAM_MULTI_CS_CONFIG_REG			0x1EC
-#define NANDHAM_AFM_SEQ_REG_1				0x200
-#define NANDHAM_AFM_SEQ_REG_2				0x204
-#define NANDHAM_AFM_SEQ_REG_3				0x208
-#define NANDHAM_AFM_SEQ_REG_4				0x20C
-#define NANDHAM_AFM_ADD					0x210
-#define NANDHAM_AFM_EXTRA				0x214
-#define NANDHAM_AFM_CMD					0x218
-#define NANDHAM_AFM_SEQ_CFG				0x21C
-#define NANDHAM_AFM_GEN_CFG				0x220
-#define NANDHAM_AFM_SEQ_STA				0x240
-#define NANDHAM_AFM_ECC_REG_0				0x280
-#define NANDHAM_AFM_ECC_REG_1				0x284
-#define NANDHAM_AFM_ECC_REG_2				0x288
-#define NANDHAM_AFM_ECC_REG_3				0x28C
-#define NANDHAM_AFM_DATA_FIFO				0x300
-
-/* BCH Controller Registers (Offsets from EMI_NAND) */
-#define NANDBCH_BOOTBANK_CFG				0x000
-#define NANDBCH_RBN_STA					0x004
-#define NANDBCH_INT_EN					0x010
-#define NANDBCH_INT_STA					0x014
-#define NANDBCH_INT_CLR					0x018
-#define NANDBCH_INT_EDGE_CFG	  			0x01C
-#define NANDBCH_CTL_TIMING				0x040
-#define NANDBCH_WEN_TIMING				0x044
-#define NANDBCH_REN_TIMING				0x048
-#define NANDBCH_BLOCK_ZERO_REMAP_REG			0x04C
-#define NANDBCH_BOOT_STATUS    			       	0x050
-#define NANDBCH_FALSE_BOOT_REG    			0x054
-#define NANDBCH_FALSE_BOOT_STATUS    			0x058
-#define NANDBCH_CONTROLLER_CFG    			0x100
-#define NANDBCH_FLEX_MUXCTRL				0x104
-#define NANDBCH_FLEX_DATAWRITE_CONFIG			0x10C
-#define NANDBCH_FLEX_DATAREAD_CONFIG 			0x110
-#define NANDBCH_VERSION_REG				0x144
-#define NANDBCH_ADDRESS_REG_1				0x1F0
-#define NANDBCH_ADDRESS_REG_2				0x1F4
-#define NANDBCH_ADDRESS_REG_3				0x1F8
-#define NANDBCH_MULTI_CS_CONFIG_REG			0x1FC
-#define NANDBCH_SEQ_REG_1       			0x200
-#define NANDBCH_SEQ_REG_2				0x204
-#define NANDBCH_SEQ_REG_3				0x208
-#define NANDBCH_SEQ_REG_4				0x20C
-#define NANDBCH_ADD					0x210
-#define NANDBCH_EXTRA_REG				0x214
-#define NANDBCH_CMD					0x218
-#define NANDBCH_GEN_CFG					0x220
-#define NANDBCH_DELAY_REG				0x224
-#define NANDBCH_SEQ_CFG					0x22C
-#define NANDBCH_SEQ_STA					0x270
-#define NANDBCH_DATA_BUFFER_ENTRY_0			0x280
-#define NANDBCH_DATA_BUFFER_ENTRY_1			0x284
-#define NANDBCH_DATA_BUFFER_ENTRY_2			0x288
-#define NANDBCH_DATA_BUFFER_ENTRY_3			0x28C
-#define NANDBCH_DATA_BUFFER_ENTRY_4			0x290
-#define NANDBCH_DATA_BUFFER_ENTRY_5			0x294
-#define NANDBCH_DATA_BUFFER_ENTRY_6			0x298
-#define NANDBCH_DATA_BUFFER_ENTRY_7			0x29C
-#define NANDBCH_ECC_SCORE_REG_A				0x2A0
-#define NANDBCH_ECC_SCORE_REG_B				0x2A4
-#define NANDBCH_CHECK_STATUS_REG_A			0x2A8
-#define NANDBCH_CHECK_STATUS_REG_B			0x2AC
-#define NANDBCH_BUFFER_LIST_PTR				0x300
-#define NANDBCH_SEQ_PTR_REG				0x304
-#define NANDBCH_ERROR_THRESHOLD_REG			0x308
-
-/* EMISS NAND BCH STPLUG Registers (Offsets from EMISS_NAND_DMA) */
-#define EMISS_NAND_RD_DMA_PAGE_SIZE 			0x000
-#define EMISS_NAND_RD_DMA_MAX_OPCODE_SIZE 		0x004
-#define EMISS_NAND_RD_DMA_MIN_OPCODE_SIZE 		0x008
-#define EMISS_NAND_RD_DMA_MAX_CHUNK_SIZE 		0x00C
-#define EMISS_NAND_RD_DMA_MAX_MESSAGE_SIZE		0x010
-
-#define EMISS_NAND_WR_DMA_PAGE_SIZE 			0x100
-#define EMISS_NAND_WR_DMA_MAX_OPCODE_SIZE 		0x104
-#define EMISS_NAND_WR_DMA_MIN_OPCODE_SIZE 		0x108
-#define EMISS_NAND_WR_DMA_MAX_CHUNK_SIZE 		0x10C
-#define EMISS_NAND_WR_DMA_MAX_MESSAGE_SIZE		0x110
-
-
-/*
- * Hamming/BCH controller interrupts
- */
-
-/* NANDxxx_INT_EN/NANDxxx_INT_STA */
-/*      Common */
-#define NAND_INT_ENABLE				(0x1 << 0)
-#define NAND_INT_RBN				(0x1 << 2)
-#define NAND_INT_SEQCHECK			(0x1 << 5)
-/*      Hamming only */
-#define NANDHAM_INT_DATA_DREQ			(0x1 << 3)
-#define NANDHAM_INT_SEQ_DREQ			(0x1 << 4)
-#define NANDHAM_INT_ECC_FIX_REQ			(0x1 << 6)
-/*      BCH only */
-#define NANDBCH_INT_SEQNODESOVER		(0x1 << 7)
-#define NANDBCH_INT_ECCTHRESHOLD		(0x1 << 8)
-
-/* NANDxxx_INT_CLR */
-/*      Common */
-#define NAND_INT_CLR_RBN			(0x1 << 2)
-#define NAND_INT_CLR_SEQCHECK			(0x1 << 3)
-/*      Hamming only */
-#define NANDHAM_INT_CLR_ECC_FIX_REQ		(0x1 << 4)
-#define NANDHAM_INT_CLR_DATA_DREQ		(0x1 << 5)
-#define NANDHAM_INT_CLR_SEQ_DREQ		(0x1 << 6)
-/*      BCH only */
-#define NANDBCH_INT_CLR_SEQNODESOVER		(0x1 << 5)
-#define NANDBCH_INT_CLR_ECCTHRESHOLD		(0x1 << 6)
-
-/* NANDxxx_INT_EDGE_CFG */
-#define NAND_EDGE_CFG_RBN_RISING		0x1
-#define NAND_EDGE_CFG_RBN_FALLING		0x2
-#define NAND_EDGE_CFG_RBN_ANY			0x3
-
-/* NANDBCH_CONTROLLER_CFG/NANDHAM_FLEXMODE_CFG */
-#define CFG_ENABLE_FLEX				0x1
-#define CFG_ENABLE_AFM				0x2
-#define CFG_RESET				(0x1 << 3)
-#define CFG_RESET_ECC(x)			(0x1 << (7 + (x)))
-#define CFG_RESET_ECC_ALL			(0xff << 7)
-
-
-/*
- * BCH Controller
- */
-
-/* ECC Modes */
-#define BCH_18BIT_ECC				0
-#define BCH_30BIT_ECC				1
-#define BCH_NO_ECC				2
-#define BCH_ECC_RSRV				3
-
-/* NANDBCH_BOOTBANK_CFG */
-#define BOOT_CFG_RESET				(0x1 << 3)
-
-/* NANDBCH_CTL_TIMING */
-#define NANDBCH_CTL_SETUP(x)			((x) & 0xff)
-#define NANDBCH_CTL_HOLD(x)			(((x) & 0xff) << 8)
-#define NANDBCH_CTL_WERBN(x)			(((x) & 0xff) << 24)
-
-/* NANDBCH_WEN_TIMING */
-#define NANDBCH_WEN_ONTIME(x)			((x) & 0xff)
-#define NANDBCH_WEN_OFFTIME(x)			(((x) & 0xff) << 8)
-#define NANDBCH_WEN_ONHALFCYCLE			(0x1 << 16)
-#define NANDBCH_WEN_OFFHALFCYCLE		(0x1 << 17)
-
-/* NANDBCH_REN_TIMING */
-#define NANDBCH_REN_ONTIME(x)			((x) & 0xff)
-#define NANDBCH_REN_OFFTIME(x)			(((x) & 0xff) << 8)
-#define NANDBCH_REN_ONHALFCYCLE			(0x1 << 16)
-#define NANDBCH_REN_OFFHALFCYCLE		(0x1 << 17)
-#define NANDBCH_REN_TELQV(x)			(((x) & 0xff) << 24)
-
-/* NANDBCH_BLOCK_ZERO_REMAP_REG */
-#define NANDBCH_BACKUP_COPY_FOUND		(0x1 << 0)
-#define NANDBCH_ORIG_CODE_CORRUPTED		(0x1 << 1)
-#define NANDBCH_BLK_ZERO_REMAP(x)		((x) >> 14)
-
-/* NANDBCH_BOOT_STATUS */
-#define NANDBCH_BOOT_MAX_ERRORS(x)		((x) & 0x1f)
-
-/* NANDBCH_GEN_CFG */
-#define GEN_CFG_DATA_8_NOT_16			(0x1 << 16)
-#define GEN_CFG_EXTRA_ADD_CYCLE			(0x1 << 18)
-#define GEN_CFG_2X8_MODE			(0x1 << 19)
-#define GEN_CFG_ECC_SHIFT			20
-#define GEN_CFG_18BIT_ECC		(BCH_18BIT_ECC << GEN_CFG_ECC_SHIFT)
-#define GEN_CFG_30BIT_ECC		(BCH_30BIT_ECC << GEN_CFG_ECC_SHIFT)
-#define GEN_CFG_NO_ECC			(BCH_NO_ECC << GEN_CFG_ECC_SHIFT)
-#define GEN_CFG_LAST_SEQ_NODE			(0x1 << 22)
-
-/* NANDBCH_SEQ_CFG */
-#define SEQ_CFG_REPEAT_COUNTER(x)		((x) & 0xffff)
-#define SEQ_CFG_SEQ_IDENT(x)			(((x) & 0xff) << 16)
-#define SEQ_CFG_DATA_WRITE			(0x1 << 24)
-#define SEQ_CFG_ERASE				(0x1 << 25)
-#define SEQ_CFG_GO_STOP				(0x1 << 26)
-
-/* NANDBCH_SEQ_STA */
-#define SEQ_STA_RUN				(0x1 << 4)
-
-/*
- * BCH Commands
- */
-#define BCH_OPC_STOP			0x0
-#define BCH_OPC_CMD			0x1
-#define BCH_OPC_INC			0x2
-#define BCH_OPC_DEC_JUMP		0x3
-#define BCH_OPC_DATA			0x4
-#define BCH_OPC_DELAY			0x5
-#define BCH_OPC_CHECK			0x6
-#define BCH_OPC_ADDR			0x7
-#define BCH_OPC_NEXT_CHIP_ON		0x8
-#define BCH_OPC_DEC_JMP_MCS		0x9
-#define BCH_OPC_ECC_SCORE		0xA
-
-#define BCH_INSTR(opc, opr)		((opc) | ((opr) << 4))
-
-#define BCH_CMD_ADDR			BCH_INSTR(BCH_OPC_CMD, 0)
-#define BCH_CL_CMD_1			BCH_INSTR(BCH_OPC_CMD, 1)
-#define BCH_CL_CMD_2			BCH_INSTR(BCH_OPC_CMD, 2)
-#define BCH_CL_CMD_3			BCH_INSTR(BCH_OPC_CMD, 3)
-#define BCH_CL_EX_0			BCH_INSTR(BCH_OPC_CMD, 4)
-#define BCH_CL_EX_1			BCH_INSTR(BCH_OPC_CMD, 5)
-#define BCH_CL_EX_2			BCH_INSTR(BCH_OPC_CMD, 6)
-#define BCH_CL_EX_3			BCH_INSTR(BCH_OPC_CMD, 7)
-#define BCH_INC(x)			BCH_INSTR(BCH_OPC_INC, (x))
-#define BCH_DEC_JUMP(x)			BCH_INSTR(BCH_OPC_DEC_JUMP, (x))
-#define BCH_STOP			BCH_INSTR(BCH_OPC_STOP, 0)
-#define BCH_DATA_1_SECTOR		BCH_INSTR(BCH_OPC_DATA, 0)
-#define BCH_DATA_2_SECTOR		BCH_INSTR(BCH_OPC_DATA, 1)
-#define BCH_DATA_4_SECTOR		BCH_INSTR(BCH_OPC_DATA, 2)
-#define BCH_DATA_8_SECTOR		BCH_INSTR(BCH_OPC_DATA, 3)
-#define BCH_DATA_16_SECTOR		BCH_INSTR(BCH_OPC_DATA, 4)
-#define BCH_DATA_32_SECTOR		BCH_INSTR(BCH_OPC_DATA, 5)
-#define BCH_DELAY_0			BCH_INSTR(BCH_OPC_DELAY, 0)
-#define BCH_DELAY_1			BCH_INSTR(BCH_OPC_DELAY, 1)
-#define BCH_OP_ERR			BCH_INSTR(BCH_OPC_CHECK, 0)
-#define BCH_CACHE_ERR			BCH_INSTR(BCH_OPC_CHECK, 1)
-#define BCH_ERROR			BCH_INSTR(BCH_OPC_CHECK, 2)
-#define BCH_AL_EX_0			BCH_INSTR(BCH_OPC_ADDR, 0)
-#define BCH_AL_EX_1			BCH_INSTR(BCH_OPC_ADDR, 1)
-#define BCH_AL_EX_2			BCH_INSTR(BCH_OPC_ADDR, 2)
-#define BCH_AL_EX_3			BCH_INSTR(BCH_OPC_ADDR, 3)
-#define BCH_AL_AD_0			BCH_INSTR(BCH_OPC_ADDR, 4)
-#define BCH_AL_AD_1			BCH_INSTR(BCH_OPC_ADDR, 5)
-#define BCH_AL_AD_2			BCH_INSTR(BCH_OPC_ADDR, 6)
-#define BCH_AL_AD_3			BCH_INSTR(BCH_OPC_ADDR, 7)
-#define BCH_NEXT_CHIP_ON		BCH_INSTR(BCH_OPC_NEXT_CHIP_ON, 0)
-#define BCH_DEC_JMP_MCS(x)		BCH_INSTR(BCH_OPC_DEC_JMP_MCS, (x))
-#define BCH_ECC_SCORE(x)		BCH_INSTR(BCH_OPC_ECC_SCORE, (x))
-
-
-/*
- * Hamming-FLEX register fields
- */
-
-/* NANDHAM_FLEX_DATAREAD/WRITE_CONFIG */
-#define FLEX_DATA_CFG_WAIT_RBN			(0x1 << 27)
-#define FLEX_DATA_CFG_BEATS_1			(0x1 << 28)
-#define FLEX_DATA_CFG_BEATS_2			(0x2 << 28)
-#define FLEX_DATA_CFG_BEATS_3			(0x3 << 28)
-#define FLEX_DATA_CFG_BEATS_4			(0x0 << 28)
-#define FLEX_DATA_CFG_BYTES_1			(0x0 << 30)
-#define FLEX_DATA_CFG_BYTES_2			(0x1 << 30)
-#define FLEX_DATA_CFG_CSN			(0x1 << 31)
-
-/* NANDHAM_FLEX_CMD */
-#define FLEX_CMD_RBN				(0x1 << 27)
-#define FLEX_CMD_BEATS_1			(0x1 << 28)
-#define FLEX_CMD_BEATS_2			(0x2 << 28)
-#define FLEX_CMD_BEATS_3			(0x3 << 28)
-#define FLEX_CMD_BEATS_4			(0x0 << 28)
-#define FLEX_CMD_CSN				(0x1 << 31)
-#define FLEX_CMD(x)				(((x) & 0xff) |		\
-						 FLEX_CMD_RBN |		\
-						 FLEX_CMD_BEATS_1 |	\
-						 FLEX_CMD_CSN)
-/* NANDHAM_FLEX_ADD */
-#define FLEX_ADDR_RBN				(0x1 << 27)
-#define FLEX_ADDR_BEATS_1			(0x1 << 28)
-#define FLEX_ADDR_BEATS_2			(0x2 << 28)
-#define FLEX_ADDR_BEATS_3			(0x3 << 28)
-#define FLEX_ADDR_BEATS_4			(0x0 << 28)
-#define FLEX_ADDR_ADD8_VALID			(0x1 << 30)
-#define FLEX_ADDR_CSN				(0x1 << 31)
-
-/*
- * Hamming-AFM register fields
- */
-/* NANDHAM_AFM_SEQ_CFG */
-#define AFM_SEQ_CFG_GO				(0x1 << 26)
-#define AFM_SEQ_CFG_DIR_WRITE			(0x1 << 24)
-
-/* NANDHAM_AFM_GEN_CFG */
-#define AFM_GEN_CFG_DATA_8_NOT_16		(0x1 << 16)
-#define AFM_GEN_CFG_LARGE_PAGE			(0x1 << 17)
-#define AFM_GEN_CFG_EXTRA_ADD_CYCLE		(0x1 << 18)
-
-/*
- * AFM Commands
- */
-#define AFM_STOP			0x0
-#define AFM_CMD				0x1
-#define AFM_INC				0x2
-#define AFM_DEC_JUMP			0x3
-#define AFM_DATA			0x4
-#define AFM_SPARE			0x5
-#define AFM_CHECK			0x6
-#define AFM_ADDR			0x7
-#define AFM_WRBN			0xA
-
-#endif /* STM_NANDC_REGS_H */
--- a/drivers/mtd/ubi/cdev.c	2012-12-23 15:47:29.000000000 +0100
+++ b/drivers/mtd/ubi/cdev.c	2012-11-11 01:39:28.000000000 +0100
@@ -628,9 +628,6 @@
 	if (req->alignment != 1 && n)
 		goto bad;
 
-	if (!req->name[0] || !req->name_len)
-		goto bad;
-
 	if (req->name_len > UBI_VOL_NAME_MAX) {
 		err = -ENAMETOOLONG;
 		goto bad;
--- a/drivers/mtd/ubi/wl.c	2012-12-23 15:47:29.000000000 +0100
+++ b/drivers/mtd/ubi/wl.c	2009-12-03 04:51:21.000000000 +0100
@@ -1036,6 +1036,7 @@
 
 	ubi_err("failed to erase PEB %d, error %d", pnum, err);
 	kfree(wl_wrk);
+	kmem_cache_free(ubi_wl_entry_slab, e);
 
 	if (err == -EINTR || err == -ENOMEM || err == -EAGAIN ||
 	    err == -EBUSY) {
@@ -1048,16 +1049,14 @@
 			goto out_ro;
 		}
 		return err;
-	}
-
-	kmem_cache_free(ubi_wl_entry_slab, e);
-	if (err != -EIO)
+	} else if (err != -EIO) {
 		/*
 		 * If this is not %-EIO, we have no idea what to do. Scheduling
 		 * this physical eraseblock for erasure again would cause
 		 * errors again and again. Well, lets switch to R/O mode.
 		 */
 		goto out_ro;
+	}
 
 	/* It is %-EIO, the PEB went bad */
 
--- a/include/linux/mtd/nand.h	2012-12-23 15:47:30.000000000 +0100
+++ b/include/linux/mtd/nand.h	2012-11-11 01:39:29.000000000 +0100
@@ -44,8 +44,8 @@
  * is supported now. If you add a chip with bigger oobsize/page
  * adjust this accordingly.
  */
-#define NAND_MAX_OOBSIZE	576
-#define NAND_MAX_PAGESIZE	8192
+#define NAND_MAX_OOBSIZE	128
+#define NAND_MAX_PAGESIZE	4096
 
 /*
  * Constants for hardware specific CLE/ALE/NCE function
@@ -79,7 +79,6 @@
 #define NAND_CMD_RNDIN		0x85
 #define NAND_CMD_READID		0x90
 #define NAND_CMD_ERASE2		0xd0
-#define NAND_CMD_PARAM          0xec
 #define NAND_CMD_RESET		0xff
 #define NAND_CMD_SETFEATURES    0xef
 #define NAND_CMD_GETFEATURES    0xee
@@ -177,21 +176,6 @@
 /* Chip does not allow subpage writes */
 #define NAND_NO_SUBPAGE_WRITE	0x00000200
 
-/* Device is one of 'new' xD cards that expose fake nand command set */
-#define NAND_BROKEN_XD		0x00000400
-
-/* Device behaves just like nand, but is readonly */
-#define NAND_ROM                0x00000800
-
-/* Device supports cache read function */
-#define NAND_CACHERD		0x00001000
-/* Device supports multi-plane read operations */
-#define NAND_MULTIPLANE_READ	0x00002000
-/* Deivce supports multi-plane program/erase operations */
-#define NAND_MULTIPLANE_PROG_ERASE	0x00004000
-/* Deivce supports multi-LUN operations */
-#define NAND_MULTILUN		0x00008000
-
 
 /* Options valid for Samsung large page devices */
 #define NAND_SAMSUNG_LP_OPTIONS \
@@ -227,19 +211,6 @@
 #define NAND_CI_CELLTYPE_MSK	0x0C
 
 /*
- * Factory-programmed bad-block marker (BBM) flags
- */
-#define NAND_BBM_PAGE_0		0x00000001
-#define NAND_BBM_PAGE_1		0x00000002
-#define NAND_BBM_PAGE_LAST	0x00000004
-#define NAND_BBM_PAGE_LMIN2	0x00000008
-#define NAND_BBM_PAGE_ALL	0x00000010
-#define NAND_BBM_BYTE_OOB_0	0x00000020
-#define NAND_BBM_BYTE_OOB_5	0x00000040
-#define NAND_BBM_BYTE_OOB_ALL	0x00000080
-#define NAND_BBM_BYTE_ALL	0x00000100
-
-/*
  * nand_state_t - chip states
  * Enumeration for NAND flash chip state
  */
@@ -256,70 +227,6 @@
 /* Keep gcc happy */
 struct nand_chip;
 
-struct nand_onfi_params {
-	/* rev info and features block */
-	/* 'O' 'N' 'F' 'I'  */
-	u8 sig[4];
-	__le16 revision;
-	__le16 features;
-	__le16 opt_cmd;
-	u8 reserved[22];
-
-	/* manufacturer information block */
-	char manufacturer[12];
-	char model[20];
-	u8 jedec_id;
-	__le16 date_code;
-	u8 reserved2[13];
-
-	/* memory organization block */
-	__le32 byte_per_page;
-	__le16 spare_bytes_per_page;
-	__le32 data_bytes_per_ppage;
-	__le16 spare_bytes_per_ppage;
-	__le32 pages_per_block;
-	__le32 blocks_per_lun;
-	u8 lun_count;
-	u8 addr_cycles;
-	u8 bits_per_cell;
-	__le16 bb_per_lun;
-	__le16 block_endurance;
-	u8 guaranteed_good_blocks;
-	__le16 guaranteed_block_endurance;
-	u8 programs_per_page;
-	u8 ppage_attr;
-	u8 ecc_bits;
-	u8 interleaved_bits;
-	u8 interleaved_ops;
-	u8 reserved3[13];
-
-	/* electrical parameter block */
-	u8 io_pin_capacitance_max;
-	__le16 async_timing_mode;
-	__le16 program_cache_timing_mode;
-	__le16 t_prog;
-	__le16 t_bers;
-	__le16 t_r;
-	__le16 t_ccs;
-	__le16 src_sync_timing_mode;
-	__le16 src_ssync_features;
-	__le16 clk_pin_capacitance_typ;
-	__le16 io_pin_capacitance_typ;
-	__le16 input_pin_capacitance_typ;
-	u8 input_pin_capacitance_max;
-	u8 driver_strenght_support;
-	__le16 t_int_r;
-	__le16 t_ald;
-	u8 reserved4[7];
-
-	/* vendor */
-	u8 reserved5[90];
-
-	__le16 crc;
-} __attribute__((packed));
-
-#define ONFI_CRC_BASE	0x4F4E
-
 /**
  * struct nand_hw_control - Control structure for hardware controller (e.g ECC generator) shared among independent devices
  * @lock:               protection lock
@@ -443,23 +350,15 @@
  * @phys_erase_shift:	[INTERN] number of address bits in a physical eraseblock
  * @bbt_erase_shift:	[INTERN] number of address bits in a bbt entry
  * @chip_shift:		[INTERN] number of address bits in one chip
- * @options:		[BOARDSPECIFIC] various chip options. They can partly
- *			be set to inform nand_scan about special functionality.
- *			See the defines for further explanation.
- * @bbm:		[INTERN] Bad block marker flags
+ * @options:		[BOARDSPECIFIC] various chip options. They can partly be set to inform nand_scan about
+ *			special functionality. See the defines for further explanation
  * @badblockpos:	[INTERN] position of the bad block marker in the oob area
- * @planes_per_chip:	[INTERN] number of planes per chip
- * @luns_per_chip:	[INTERN] number of LUNs per chip
  * @cellinfo:		[INTERN] MLC/multichip data from chip ident
  * @numchips:		[INTERN] number of physical chips
  * @chipsize:		[INTERN] the size of one chip for multichip arrays
  * @pagemask:		[INTERN] page number mask = number of (pages / chip) - 1
  * @pagebuf:		[INTERN] holds the pagenumber which is currently in data_buf
  * @subpagesize:	[INTERN] holds the subpagesize
- * @onfi_version:	[INTERN] holds the chip ONFI version (BCD encoded),
- *			non 0 if ONFI supported.
- * @onfi_params:	[INTERN] holds the ONFI page parameter when ONFI is
- *			supported, 0 otherwise.
  * @ecclayout:		[REPLACEABLE] the default ecc placement scheme
  * @bbt:		[INTERN] bad block table pointer
  * @bbt_td:		[REPLACEABLE] bad block table descriptor for flash lookup
@@ -498,7 +397,6 @@
 
 	int		chip_delay;
 	unsigned int	options;
-	unsigned int	bbm;
 
 	int		page_shift;
 	int		phys_erase_shift;
@@ -511,11 +409,6 @@
 	int		subpagesize;
 	uint8_t		cellinfo;
 	int		badblockpos;
-	int		planes_per_chip;
-	int		luns_per_chip;
-
-	int onfi_version;
-	struct nand_onfi_params	onfi_params;
 
 	nand_state_t	state;
 
@@ -550,7 +443,6 @@
 #define NAND_MFR_HYNIX		0xad
 #define NAND_MFR_MICRON		0x2c
 #define NAND_MFR_AMD		0x01
-#define NAND_MFR_MACRONIX	0xc2
 
 /**
  * struct nand_flash_dev - NAND Flash Device ID Structure
@@ -585,11 +477,6 @@
 
 extern struct nand_flash_dev nand_flash_ids[];
 extern struct nand_manufacturers nand_manuf_ids[];
-extern int nand_decode_id(struct mtd_info *mtd, struct nand_chip *chip,
-			  struct nand_flash_dev *type, uint8_t *id,
-			  int max_id_len);
-extern void nand_derive_bbm(struct mtd_info *mtd, struct nand_chip *chip,
-			    uint8_t *id);
 
 /**
  * struct nand_bbt_descr - bad block table descriptor
@@ -675,10 +562,7 @@
 extern int nand_get_device(struct nand_chip *chip,
 			   struct mtd_info *mtd, int new_state);
 extern void nand_release_device(struct mtd_info *mtd);
-extern int nand_suspend(struct mtd_info *mtd);
-extern void nand_resume(struct mtd_info *mtd);
-extern void nand_sync(struct mtd_info *mtd);
-extern u8 nand_erasebb;
+
 
 /*
 * Constants for oob configuration
--- a/include/linux/mtd/physmap.h	2012-12-23 15:47:30.000000000 +0100
+++ b/include/linux/mtd/physmap.h	2009-12-03 04:51:21.000000000 +0100
@@ -26,9 +26,6 @@
 	unsigned int		nr_parts;
 	unsigned int		pfow_base;
 	struct mtd_partition	*parts;
-#ifdef CONFIG_MTD_COMPLEX_MAPPINGS
-	void			(*map_init)(struct map_info *);
-#endif
 };
 
 /*
--- a/include/linux/mtd/stm_emi_wp_map.h	2012-12-23 15:47:30.000000000 +0100
+++ b/include/linux/mtd/stm_emi_wp_map.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
-/*
- * include/linux/mtd/stm_emi_wp_map.h: STMicroelectronics EMI 'Write-Protect'
- * Mapping
- *
- * Copyright (C) 2011 STMicroelectronics Limited
- *
- * May be copied or modified under the terms of the GNU General Public License.
- * See linux/COPYING for more information.
- */
-
-#ifndef STM_EMI_WP_MAP_H
-#define STM_EMI_WP_MAP_H
-
-#include <linux/mtd/map.h>
-
-void stm_emi_map_init(struct map_info *map);
-
-#endif /* STM_EMI_WP_MAP_H */
*** a/drivers/mtd/chips/cfi_probe.c	2011-01-02 21:05:30.000000000 +0100
--- b/cfi_probe.c	2011-01-05 20:38:36.087467593 +0100
***************
*** 221,226 ****
--- 221,242 ----
  	for (i=0; i<cfi->cfiq->NumEraseRegions; i++) {
  		cfi->cfiq->EraseRegionInfo[i] = le32_to_cpu(cfi->cfiq->EraseRegionInfo[i]);
  
+ 	/* kdhong */
+ 	printk( "CFI MFR = %x DEV = %x\n", cfi->mfr, cfi->id );
+ 
+ 	if( cfi->mfr == 0x00c2 && cfi->id == 0x227e )
+ 	{
+ 		int devsize = (1 << cfi->cfiq->DevSize) * cfi->interleave;
+ 
+ 		printk( "devsize = %x\n", devsize );
+ 
+ 		if( devsize == 0x400000 )
+ 		{
+ 			cfi->cfiq->EraseRegionInfo[i] = 0x100003f;
+ 		}
+ 	}
+ 	/* kdhong */
+ 
  #ifdef DEBUG_CFI
  		printk("  Erase Region #%d: BlockSize 0x%4.4X bytes, %d blocks\n",
  		       i, (cfi->cfiq->EraseRegionInfo[i] >> 8) & ~0xff,
--- a/drivers/stm/stx7111_comms.c.org	2011-07-02 05:58:19.000000000 -0700
+++ b/drivers/stm/stx7111_comms.c	2011-07-03 05:30:59.771608244 -0700
@@ -211,10 +211,17 @@
 			STM_PAD_PIO_BIDIR_NAMED(2, 0, 1, "SCL"),
 			STM_PAD_PIO_BIDIR_NAMED(2, 1, 1, "SDA"),
 		},
-		.sysconfs_num = 1,
+		.sysconfs_num = 5,
 		.sysconfs = (struct stm_pad_sysconf []) {
 			/* SSC0_MUX_SEL = 0 (default assignment) */
 			STM_PAD_SYS_CFG(7, 1, 1, 0),
+
+			/* some additional sysconfig settings to enable i2c, cic and cec */
+			STM_PAD_SYS_CFG(5, 0, 0, 1), // cic
+			STM_PAD_SYS_CFG(5, 17, 17, 1), // cic
+			STM_PAD_SYS_CFG(5, 8, 8, 1), //cec
+			STM_PAD_SYS_CFG(7, 15, 15, 1), //i2c
+
 			/* spi_boot_not_comm = 0 should be set here... */
 			/* This is a signal from SPI block */
 			/* Hope this is set correctly by default */
 
--- a/arch/sh/boards/mach-mb618/setup.c.org	2012-03-08 08:58:51.000000000 -0800
+++ b/arch/sh/boards/mach-mb618/setup.c	2012-03-09 08:48:35.000000000 -0800
@@ -17,35 +17,78 @@
 #include <linux/phy.h>
 #include <linux/i2c.h>
 #include <linux/gpio.h>
+#include <linux/stm/gpio.h>
 #include <linux/gpio_keys.h>
 #include <linux/input.h>
 #include <linux/irq.h>
 #include <linux/stm/platform.h>
 #include <linux/stm/stx7111.h>
 #include <linux/stm/emi.h>
-#include <linux/stm/pci-glue.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/nand.h>
+#include <linux/stm/nand.h>
 #include <linux/mtd/physmap.h>
 #include <linux/mtd/partitions.h>
-#include <linux/spi/spi.h>
-#include <linux/spi/flash.h>
 #include <asm/irq-ilc.h>
 #include <asm/irl.h>
 #include <sound/stm.h>
 #include <mach/common.h>
+#include <linux/bpa2.h>
 
+#define MB618_PIO_PHY_RESET stm_gpio(4, 4)
 
-
-/* Whether the hardware supports NOR or NAND Flash depends on J34.
- * In position 1-2 CSA selects NAND, in position 2-3 is selects NOR.
- * Note that J30A must be in position 2-3 to select the on board Flash
- * (both NOR and NAND).
- */
-#define FLASH_NOR
-#define MB618_PIO_FLASH_VPP stm_gpio(3, 4)
-
-
+const char *LMI_IO_partalias[] = { "v4l2-coded-video-buffers", "BPA2_Region1", "v4l2-video-buffers" ,
+                                    "coredisplay-video", "gfx-memory", "BPA2_Region0", "LMI_VID", NULL };
+ 
+#ifdef CONFIG_BPA2_DIRECTFBOPTIMIZED
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x47600000 - 0x483FFFFF - bigphys ( 14mb (0x00E00000))
+0x48400000 - 0x4FFFFFFF - lmi_io  ( 124mb (0x07C00000))
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x47600000,
+ 	    .size  = 0x07C00000, /* 124 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x4F200000,
+ 	    .size  = 0x00E00000, /* 14 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+ };
+#else
+/*
+0x40000000 - 0x403FFFFF - cocpu 1 ram (4mb)
+0x40400000 - 0x407FFFFF - cocpu 2 ram (4mb)
+0x40800000 - 0x47FFFFFF - linux   (120mb) 
+0x48000000 - 0x49FFFFFF - bigphys ( 32mb)
+0x4A000000 - 0x4FFFFFFF - lmi_io  ( 96mb)
+*/
+static struct bpa2_partition_desc bpa2_parts_table[] = {
+    {
+ 	    .name  = "bigphysarea",
+ 	    .start = 0x48000000,
+ 	    .size  = 0x02000000, /* 32 Mb */
+ 	    .flags = 0,
+ 	    .aka   = NULL
+    }, 
+    {
+ 	    .name  = "LMI_IO",
+ 	    .start = 0x4A000000,
+ 	    .size  = 0x06000000, /* 96 Mb */
+ 	    .flags = 0,
+ 	    .aka   = LMI_IO_partalias
+    }, 
+ };
+#endif
 
 static void __init mb618_setup(char** cmdline_p)
 {
@@ -53,119 +70,85 @@
 
 	stx7111_early_device_init();
 
-	stx7111_configure_asc(2, &(struct stx7111_asc_config) {
+	stx7111_configure_asc(1, &(struct stx7111_asc_config) {
 			.hw_flow_control = 1,
 			.is_console = 1, });
-	stx7111_configure_asc(3, &(struct stx7111_asc_config) {
-			.hw_flow_control = 1,
-			.is_console = 0, });
-}
-
-
-
-static struct platform_device mb618_leds = {
-	.name = "leds-gpio",
-	.id = -1,
-	.dev.platform_data = &(struct gpio_led_platform_data) {
-		.num_leds = 2,
-		.leds = (struct gpio_led[]) {
-			{
-				.name = "HB green",
-				.default_trigger = "heartbeat",
-				.gpio = stm_gpio(6, 0),
-			}, {
-				.name = "HB red",
-				.gpio = stm_gpio(6, 1),
-			},
-		},
-	},
-};
-
 
+  	bpa2_init(bpa2_parts_table, ARRAY_SIZE(bpa2_parts_table));
+}
 
-static struct gpio_keys_button mb618_buttons[] = {
+// Nor Flash Configuration
+static struct mtd_partition nor_parts[] = {
 	{
-		.code = BTN_0,
-		.gpio = stm_gpio(6, 2),
-		.desc = "SW2",
-	}, {
-		.code = BTN_1,
-		.gpio = stm_gpio(6, 3),
-		.desc = "SW3",
-	}, {
-		.code = BTN_2,
-		.gpio = stm_gpio(6, 4),
-		.desc = "SW4",
+		.name   = "NOR U-BOOT     0xA000.0000-0xA007.FFFF (512KB)",
+		.size   = 0x00080000,
+		.offset = 0
 	}, {
-		.code = BTN_3,
-		.gpio = stm_gpio(6, 5),
-		.desc = "SW5",
-	},
-};
-
-static struct platform_device mb618_button_device = {
-	.name = "gpio-keys",
-	.id = -1,
-	.num_resources = 0,
-	.dev.platform_data = &(struct gpio_keys_platform_data) {
-		.buttons = mb618_buttons,
-		.nbuttons = ARRAY_SIZE(mb618_buttons),
-	},
+		.name   = "NOR R00T       0xA008.0000-0xA03F.FFFF (3,5MB)",
+		.size   = MTDPART_SIZ_FULL,
+		.offset = MTDPART_OFS_APPEND
+	}
 };
 
-
-
-#ifdef FLASH_NOR
-/* J34 must be in the 1-2 position to enable NOR Flash */
-static void mb618_nor_set_vpp(struct map_info *info, int enable)
-{
-	gpio_set_value(MB618_PIO_FLASH_VPP, enable);
-}
-
-static struct platform_device mb618_nor_flash = {
+static struct platform_device mb618_nor_device = {
 	.name		= "physmap-flash",
 	.id		= -1,
 	.num_resources	= 1,
 	.resource	= (struct resource[]) {
-		STM_PLAT_RESOURCE_MEM(0, 32*1024*1024),
+		STM_PLAT_RESOURCE_MEM(0, 4*1024*1024),
 	},
 	.dev.platform_data = &(struct physmap_flash_data) {
 		.width		= 2,
-		.set_vpp	= mb618_nor_set_vpp,
-		.nr_parts	= 3,
-		.parts		=  (struct mtd_partition []) {
-			{
-				.name = "NOR Flash 1",
-				.size = 0x00080000,
-				.offset = 0x00000000,
-			}, {
-				.name = "NOR Flash 2",
-				.size = 0x00200000,
-				.offset = MTDPART_OFS_NXTBLK,
-			}, {
-				.name = "NOR Flash 3",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
+		.nr_parts	= ARRAY_SIZE(nor_parts),
+		.parts		= nor_parts
 	},
 };
+
+// Nand Flash Configuration
+static struct mtd_partition nand_parts[] = {
+#ifdef ORIGINAL_MTD
+	 {
+	 .name = "NAND KERNEL    0x0000.0000-0x002F.FFFF",
+	 .size = 0x300000,
+	 .offset = 0
+	 }, {
+	 .name = "NAND ROOT      0x0030.0000-0x027F.FFFF",
+	 .size = 0x2500000,
+	 .offset = 0x300000
+	 }, {
+	 .name = "NAND CONFIG    0x0280.0000-0x04FF.FFFF",
+	 .size = 0x2800000,
+	 .offset = 0x2800000
+	 }, {
+	 .name = "NAND DATA      0x0500.0000-0x07FF.FFFF",
+	 .size = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = 0x05000000
+	 }
 #else
-struct stm_nand_bank_data mb618_nand_flash = {
-	.csn		= 0,
+	 {
+	 .name   = "NAND KERNEL    0x0000.0000-0x003F.FFFF (  4MB)",
+	 .size   = 0x400000,
+	 .offset = 0
+	 }, {
+	 .name   = "NAND FW        0x0040.0000-0x00BF.FFFF (  8MB)",
+	 .size   = 0x800000,
+	 .offset = MTDPART_OFS_APPEND
+	 }, {
+	 .name   = "NAND ROOT      0x00C0.0000-0x04BF.FFFF ( 64MB)",
+	 .size   = 0x4000000,
+	 .offset = MTDPART_OFS_APPEND
+	 }, {
+	 .name   = "NAND DATA      0x04C0.0000-0x07FF.FFFF ( 52MB)",
+	 .size   = MTDPART_SIZ_FULL,	/* will expand to the end of the flash */
+	 .offset = MTDPART_OFS_APPEND
+	 }
+#endif
+};
+static struct stm_nand_bank_data nand_bank_data = {
+	.csn		= 1,
+	.nr_partitions	= ARRAY_SIZE(nand_parts),
+	.partitions	= nand_parts,
 	.options	= NAND_NO_AUTOINCR | NAND_USE_FLASH_BBT,
-	.nr_partitions	= 2,
-	.partitions	= (struct mtd_partition []) {
-		{
-			.name	= "NAND Flash 1",
-			.offset	= 0,
-			.size 	= 0x00800000
-		}, {
-			.name	= "NAND Flash 2",
-			.offset = MTDPART_OFS_NXTBLK,
-			.size	= MTDPART_SIZ_FULL
-		},
-	},
 	.timing_data	= &(struct stm_nand_timing_data) {
 		.sig_setup	= 50,		/* times in ns */
 		.sig_hold	= 50,
@@ -171,37 +154,21 @@
 		.sig_hold	= 50,
 		.CE_deassert	= 0,
 		.WE_to_RBn	= 100,
-		.wr_on		= 20,
-		.wr_off		= 50,
-		.rd_on		= 20,
-		.rd_off		= 50,
+		.wr_on		= 10,
+		.wr_off		= 30,
+		.rd_on		= 10,
+		.rd_off		= 30,
		.chip_delay	= 50,		/* in us */
 	},
+	.emi_withinbankoffset	= 0,
 };
-#endif
 
-/* Serial Flash (Board Rev D and later) */
-static struct spi_board_info mb618_serial_flash = {
-	.modalias       = "m25p80",
-	.bus_num        = 0,
-	.chip_select    = stm_gpio(6, 7),
-	.max_speed_hz   = 7000000,
-	.mode           = SPI_MODE_3,
-	.platform_data  = &(struct flash_platform_data) {
-		.name = "m25p80",
-		.type = "m25p80",
-		.nr_parts	= 2,
-		.parts = (struct mtd_partition []) {
-			{
-				.name = "Serial Flash 1",
-				.size = 0x00080000,
-				.offset = 0,
-			}, {
-				.name = "Serial Flash 2",
-				.size = MTDPART_SIZ_FULL,
-				.offset = MTDPART_OFS_NXTBLK,
-			},
-		},
+static struct platform_device mb618_nand_device = {
+	.name		= "stm-nand-emi",
+	.dev.platform_data = &(struct stm_plat_nand_emi_data){
+		.nr_banks	= 1,
+		.banks		= &nand_bank_data,
+		.emi_rbn_gpio	= -1,
 	},
 };
 
@@ -216,13 +183,13 @@
 	return 1;
 }
 
-static struct stmmac_mdio_bus_data stmmac_mdio_bus = {
+static struct stmmac_mdio_bus_data mb618_phy_private_data = {
 	.bus_id = 0,
 	.phy_reset = mb618_phy_reset,
 	.phy_mask = 0,
 };
 
-static struct platform_device epld_device = {
+static struct platform_device mb618_epld_device = {
 	.name		= "epld",
 	.id		= -1,
 	.num_resources	= 1,
@@ -239,129 +206,39 @@
 	},
 };
 
-
-
-static struct stm_plat_pci_config mb618_pci_config = {
-	/* We don't bother with INT[BCD] as they are shared with the ssc
-	 * J20-A must be removed, J20-B must be 5-6 */
-	.pci_irq = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.serr_irq = PCI_PIN_DEFAULT, /* J32-F fitted */
-	.idsel_lo = 30,
-	.idsel_hi = 30,
-	.req_gnt = {
-		[0] = PCI_PIN_DEFAULT,
-		[1] = PCI_PIN_UNUSED,
-		[2] = PCI_PIN_UNUSED,
-		[3] = PCI_PIN_UNUSED
-	},
-	.pci_clk = 33333333,
-	.pci_reset_gpio = -EINVAL,	/* Reset done by EPLD on power on */
-};
-
-int pcibios_map_platform_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-       /* We can use the standard function on this board */
-       return stx7111_pcibios_map_platform_irq(&mb618_pci_config, pin);
-}
-
 static struct platform_device *mb618_devices[] __initdata = {
-	&mb618_leds,
-	&epld_device,
-#ifdef FLASH_NOR
-	&mb618_nor_flash,
-#endif
-	&mb618_button_device,
-};
-
-/* SCART switch simple control */
-
-/* Enable CVBS output to both (TV & VCR) SCART outputs */
-static int mb618_scart_audio_init(struct i2c_client *client, void *priv)
-{
-	const char cmd[] = { 0x2, 0x11 };
-	int cmd_len = sizeof(cmd);
-
-	return i2c_master_send(client, cmd, cmd_len) != cmd_len;
-}
-
-/* Audio on SCART outputs control */
-static struct i2c_board_info mb618_scart_audio __initdata = {
-	I2C_BOARD_INFO("snd_conv_i2c", 0x4b),
-	.type = "STV6417",
-	.platform_data = &(struct snd_stm_conv_i2c_info) {
-		.group = "Analog Output",
-		.source_bus_id = "snd_pcm_player.1",
-		.channel_from = 0,
-		.channel_to = 1,
-		.format = SND_STM_FORMAT__I2S |
-				SND_STM_FORMAT__SUBFRAME_32_BITS,
-		.oversampling = 256,
-		.init = mb618_scart_audio_init,
-		.enable_supported = 1,
-		.enable_cmd = (char []){ 0x01, 0x09 },
-		.enable_cmd_len = 2,
-		.disable_cmd = (char []){ 0x01, 0x00 },
-		.disable_cmd_len = 2,
-	},
+	&mb618_epld_device,
+	&mb618_nor_device,
+	&mb618_nand_device,
 };
 
 static int __init mb618_devices_init(void)
 {
-	int peripherals_i2c_bus;
-
-	stx7111_configure_pci(&mb618_pci_config);
-
-	stx7111_configure_pwm(&(struct stx7111_pwm_config) {
-			.out0_enabled = 1,
-			.out1_enabled = 0, });
-
-	stx7111_configure_ssc_spi(0, NULL);
+	stx7111_configure_ssc_i2c(0, NULL);
 	stx7111_configure_ssc_i2c(1, NULL); /* J12=1-2, J16=1-2 */
-	peripherals_i2c_bus = stx7111_configure_ssc_i2c(2, NULL);
+	stx7111_configure_ssc_i2c(2, NULL);
 	stx7111_configure_ssc_i2c(3, NULL);
 
 	stx7111_configure_usb(&(struct stx7111_usb_config) {
 			.invert_ovrcur = 1, });
 
+	gpio_request(MB618_PIO_PHY_RESET, "PHY_RESET");
+	gpio_direction_output(MB618_PIO_PHY_RESET, STM_GPIO_DIRECTION_OUT);
+	gpio_set_value(MB618_PIO_PHY_RESET, 1);
+
 	stx7111_configure_ethernet(&(struct stx7111_ethernet_config) {
 			.mode = stx7111_ethernet_mode_mii,
 			.ext_clk = 0,
 			.phy_bus = 0,
 			.phy_addr = -1,
-			.mdio_bus_data = &stmmac_mdio_bus,
+			.mdio_bus_data = &mb618_phy_private_data,
 		});
 
-	stx7111_configure_lirc(&(struct stx7111_lirc_config) {
-#ifdef CONFIG_LIRC_STM_UHF
-			.rx_mode = stx7111_lirc_rx_mode_uhf,
-#else
-			.rx_mode = stx7111_lirc_rx_mode_ir,
-#endif
-			.tx_enabled = 1,
-			.tx_od_enabled = 0, });
-
-	gpio_request(MB618_PIO_FLASH_VPP, "Flash VPP");
-	gpio_direction_output(MB618_PIO_FLASH_VPP, 0);
-
-	i2c_register_board_info(peripherals_i2c_bus, &mb618_scart_audio, 1);
-	spi_register_board_info(&mb618_serial_flash, 1);
-
-#ifndef FLASH_NOR
 	stx7111_configure_nand(&(struct stm_nand_config) {
 			.driver = stm_nand_flex,
 			.nr_banks = 1,
-			.banks = &mb618_nand_flash,
-			.rbn.flex_connected = 1,});
-
-	/* The MTD NAND code doesn't understand the concept of VPP,
-	 * (or hardware write protect) so permanently enable it. */
-	gpio_direction_output(MB618_PIO_FLASH_VPP, 1);
-#endif
+			.banks = &nand_bank_data,
+			.rbn.flex_connected = 0,});
 
 	return platform_add_devices(mb618_devices, ARRAY_SIZE(mb618_devices));
 }
@@ -405,7 +282,7 @@
 	const int version_offset = 0;
 	int version;
 
-	epld_early_init(&epld_device);
+	epld_early_init(&mb618_epld_device);
 
 	epld_write(0, 0);	/* bank = Test */
 	epld_write(0x63, test_offset);
@@ -438,10 +315,9 @@
 }
 
 struct sh_machine_vector mv_mb618 __initmv = {
-	.mv_name		= "STx7111 Mboard",
+	.mv_name		= "STx7111 Mboard (Kathrein UFS-912)",
 	.mv_setup		= mb618_setup,
 	.mv_nr_irqs		= NR_IRQS,
 	.mv_init_irq		= mb618_init_irq,
 	.mv_ioport_map		= mb618_ioport_map,
-	STM_PCI_IO_MACHINE_VEC
 };
